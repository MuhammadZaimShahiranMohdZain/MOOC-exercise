<!DOCTYPE HTML>
<!-- saved from url=(0074)http://mooc.cs.helsinki.fi/programming-part2/material/week-12 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><HTML 
lang="en" lang="en" xml:lang="en" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><META content="IE=11.0000" 
http-equiv="X-UA-Compatible">
 
<META http-equiv="Content-Type" content="text/html; charset=utf-8">   
<TITLE>MOOC | MOOC - Massiivinen avoin verkkokurssi</TITLE>    <LINK href="/sites/mooc.cs.helsinki.fi/files/acquia_marina_favicon.png" 
rel="shortcut icon" type="image/x-icon">   <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/5c1587b6907a85bc361bd4b70014b0e3.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/node.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/defaults.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/system.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/system-menus.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/user.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/content-module.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/ckeditor.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/ctools.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/date.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/panels.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/views.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/aeb58e3ce47f9171327ad9fd87a26c8e.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/flexible.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/style.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/typography.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/superfish.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/superfish-navbar.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/superfish-vertical.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/fusion-acquia-marina-style.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/custom.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/common.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/exercises.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/menu.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_style.css" 
rel="stylesheet" type="text/css" media="all">   <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/grid16-fluid.css" 
rel="stylesheet" type="text/css" media="all">   <!--[if IE 8]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie8-fixes.css?8" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie8-fixes.css?8" />
  <![endif]--> 
  <!--[if IE 7]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie7-fixes.css?8" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie7-fixes.css?8" />
  <![endif]--> 
  <!--[if lte IE 6]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie6-fixes.css?8"/>
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie6-fixes.css?8"/>
  <![endif]--> 
    
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/jquery.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/drupal.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/panels.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/jquery.bgiframe.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/hoverIntent.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/supposition.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/supersubs.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/superfish.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/script.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/jquery.corner.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/acquia-marina-script.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/util-functions.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/clear-default-text.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_java.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_main.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_ruby.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_scala.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT type="text/javascript">
<!--//--><![CDATA[//><!--
jQuery.extend(Drupal.settings, { "basePath": "/" });
//--><!]]>
</SCRIPT>
 
<META name="GENERATOR" content="MSHTML 11.00.9600.18163"></HEAD>
<BODY class="not-front not-logged-in page-node node-type-weekly-tasks no-sidebars full-node panels layout-main sidebars-both-first font-family-lucida font-size-13 grid-type-fluid grid-width-16 fluid-100" 
id="pid-programming-part2-material-week-12">   
<DIV class="page" id="page">
<DIV class="page-inner" id="page-inner">
<DIV id="skip"><A href="http://mooc.cs.helsinki.fi/programming-part2/material/week-12?noredirect=1#main-content-area">Skip 
to Main Content Area</A>       </DIV><!-- header-top row: width = grid_width --> 
            <!-- header-group row: width = grid_width -->       
<DIV class="header-group-wrapper full-width" id="header-group-wrapper">
<DIV class="header-group row grid16-16" id="header-group">
<DIV class="header-group-inner inner clearfix" id="header-group-inner">
<DIV class="primary-menu block" id="primary-menu">
<DIV class="primary-menu-inner inner clearfix" id="primary-menu-inner">
<UL class="menu sf-menu">
  <LI class="expanded first"><A title="" 
  href="http://mooc.cs.helsinki.fi/home">Kurssit ››</A>
  <UL class="menu">
    <LI class="leaf first"><A title="" 
    href="http://mooc.fi/algoritmit">Algoritmien MOOC</A></LI>
    <LI class="leaf"><A title="" href="http://mooc.cs.helsinki.fi/2014-ohjelmointi">Olio-ohjelmointi 
    Javalla</A></LI>
    <LI class="leaf"><A title="" 
    href="http://mooc.aalto.fi/ohjelmointi/">Ohjelmointia Scalalla</A></LI>
    <LI class="leaf"><A title="" 
    href="http://mooc.fi/programming-part1">Object-Oriented Programming with 
    Java, part I</A></LI>
    <LI class="leaf"><A title="" 
    href="http://mooc.fi/programming-part2">Object-Oriented Programming with 
    Java, part II</A></LI>
    <LI class="leaf last"><A title="" 
    href="http://mooc.cs.helsinki.fi/wepa">Web-palvelinohjelmointi</A></LI></UL></LI>
  <LI class="collapsed"><A title="Mikä on MOOC?" href="http://mooc.cs.helsinki.fi/content/mik%C3%A4-mooc">Mikä 
  on MOOC? ››</A></LI>
  <LI class="leaf last"><A title="" href="http://mooc.cs.helsinki.fi/content/j%C3%A4rjest%C3%A4v%C3%A4st%C3%A4-tahosta">Järjestävästä 
  tahosta ››</A></LI></UL></DIV><!-- /primary-menu-inner --> </DIV><!-- /primary-menu --> 
          </DIV><!-- /header-group-inner -->         </DIV><!-- /header-group --> 
      </DIV><!-- /header-group-wrapper -->       <!-- preface-top row: width = grid_width --> 
        <!--            <div id="preface-top-wrapper" class="preface-top-wrapper full-width">
        <div id="preface-top" class="preface-top row grid16-16">
          <div id="preface-top-inner" class="preface-top-inner inner clearfix"> 
--> 
          </DIV><!-- /preface-top-inner -->         </DIV><!-- /preface-top -->  
     <!-- /preface-top-wrapper -->           <!-- main row: width = grid_width --> 
    
<DIV class="main-wrapper full-width" id="main-wrapper">
<DIV class="main row grid16-16" id="main">
<DIV class="main-inner inner clearfix" id="main-inner"><!-- main group: width = grid_width - sidebar_first_width --> 
          
<DIV class="main-group row nested grid16-16" id="main-group">
<DIV class="main-group-inner inner clearfix" id="main-group-inner">
<DIV class="main-content row nested" id="main-content">
<DIV class="main-content-inner inner clearfix" id="main-content-inner"><!-- content group: width = grid_width - (sidebar_first_width + sidebar_last_width) --> 
                    
<DIV class="content-group row nested " id="content-group" style="width: 100%;">
<DIV class="content-group-inner inner clearfix" id="content-group-inner">
<DIV class="content-region row nested" id="content-region">
<DIV class="content-region-inner inner clearfix" id="content-region-inner"><A 
name="main-content-area" id="main-content-area"></A>                             
                            
<DIV class="content-inner block" id="content-inner">
<DIV class="content-inner-inner inner clearfix" id="content-inner-inner">
<DIV class="content-content" id="content-content">
<DIV class="panel-flexible panels-flexible-13 clear-block">
<DIV class="panel-flexible-inside panels-flexible-13-inside">
<DIV class="panels-flexible-row panels-flexible-row-13-7 panels-flexible-row-first clear-block ">
<DIV class="inside panels-flexible-row-inside panels-flexible-row-13-7-inside panels-flexible-row-inside-first clear-block">
<DIV class="panels-flexible-region panels-flexible-region-13-js_ panels-flexible-region-first panels-flexible-region-last ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js_-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<DIV class="panel-pane pane-custom pane-2 ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<H1 class="title"><A 
href="http://mooc.cs.helsinki.fi/programming-part2">Object-Oriented Programming 
with Java, part II ››</A></H1></DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block -->
<DIV class="panel-region-separator"></DIV>
<DIV class="panel-pane pane-custom pane-3 ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content"><LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/menu(1).css" 
rel="stylesheet" type="text/css" media="screen"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/common-new.css" 
rel="stylesheet" type="text/css" media="screen, print"> <LINK href="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_style(1).css" 
rel="stylesheet" type="text/css" media="screen, print">        </DIV></DIV><!-- /inner-inner -->
	   </DIV><!-- /inner-wrapper -->     
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV></DIV></DIV>
<DIV class="panels-flexible-row panels-flexible-row-13-4 clear-block js">
<DIV class="inside panels-flexible-row-inside panels-flexible-row-13-4-inside clear-block">
<DIV class="panels-flexible-region panels-flexible-region-13-js_en_ panels-flexible-region-first ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js_en_-inside panels-flexible-region-inside-first"></DIV></DIV>
<DIV class="panels-flexible-region panels-flexible-region-13-js ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js-inside">
<DIV class="panel-pane pane-node ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="node odd full-node node-type-page" id="node-222">
<DIV class="inner">
<H2 class="title"><A title="" 
href="http://mooc.cs.helsinki.fi/content/js-en"></A></H2>
<DIV class="content clearfix">
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/bootstrap.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/jquery-1.7.1.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/exercises-eng-new.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/common-mooc-eng.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_main.min(1).js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sh_java.min(1).js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/jquery.easing.js" type="text/javascript"></SCRIPT>
 
<DIV class="menu" id="toc" data-first-exercise-index="1" 
data-first-chapter-index="1"><SPAN id="materiaali_toc"></SPAN>           <!--div id="tehtavat_toc" ></div--> 
          <SPAN id="tehtavat_toc2"></SPAN>         </DIV></DIV></DIV><!-- /inner --> 
  </DIV><!-- /node-222 -->         </DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV>
<DIV class="panels-flexible-region panels-flexible-region-13-copyright panels-flexible-region-last float-right">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-copyright-inside panels-flexible-region-inside-last">
<DIV class="panel-pane pane-custom pane-1 box ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<P><A href="http://creativecommons.org/licenses/by-nc-sa/2.0/" 
rel="license"><IMG style="border-width: 0px; float: right;" alt="Creative Commons License" 
src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/88x31.png"></A><SMALL>This 
material is licensed under the Creative Commons BY-NC-SA license, which means 
that you can use it and distribute it freely so long as you do not erase the 
names of the original authors. If you do changes in the material and want to 
distribute this altered version of the material, you have to license it with a 
similar free license. The use of the material for commercial use is prohibited 
without a separate agreement.</SMALL></P></DIV></DIV><!-- /inner-inner -->	   
</DIV><!-- /inner-wrapper -->     
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block -->
<DIV class="panel-region-separator"></DIV>
<DIV class="panel-pane pane-content-field pane-field-author course-menu ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="field field-type-text field-field-author">
<DIV class="field-items">
<DIV class="field-item odd">                    Authors: Arto Vihavainen, Matti 
Luukkainen        </DIV></DIV></DIV></DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block -->
<DIV class="panel-region-separator"></DIV>
<DIV class="panel-pane pane-content-field pane-field-translators course-menu ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="field field-type-text field-field-translators">
<DIV class="field-items">
<DIV class="field-item odd">                    Translators: Simone Romeo, Kenny 
Heinonen        </DIV></DIV></DIV></DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV></DIV></DIV>
<DIV class="panels-flexible-row panels-flexible-row-13-8 panels-flexible-row-last clear-block js en">
<DIV class="inside panels-flexible-row-inside panels-flexible-row-13-8-inside panels-flexible-row-inside-last clear-block">
<DIV class="panels-flexible-region panels-flexible-region-13-js_en panels-flexible-region-first panels-flexible-region-last ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js_en-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<DIV class="panel-pane pane-node-content box-mooc ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="node even full-node node-type-weekly_tasks" id="node-327">
<DIV class="inner">
<DIV class="content clearfix">
<DIV class="viikkoraja-mooc" id="Week 12" data-first-exercise-index="151" 
data-first-chapter-index="53" tekija="Arto Vihavainen, Matti Luukkainen" 
data-first-week-index-mooc="12" data-first-exercise-index-mooc="44" 
data-first-chapter-index-mooc="54" data-first-week-index="12" deadline="unlocks when 85% of week 11 done ">
<H2>Some Useful Techniques</H2>
<P>Before the course comes to its end, we can still have a look at some useful 
particular features of Java.</P>
<H3>Regular Expressions</H3>
<P>A regular expression is a compact form to define a string. Regular 
expressions are often used to check the validity of strings. Let's have a look 
at an exercise where we have to check whether the student number given by the 
user is written in the valid form or not. Finnish student numbers start with the 
string "01" which is followed by seven numerical digits from 0 to 9.</P>
<P>We can check the validity of a student number parsing its each character with 
the help of the method <CODE>charAt</CODE>. Another way would be checking 
whether the first character is "0", and using the method 
<CODE>Integer.parseInt</CODE> to translate the string into a number. Then, we 
could check whether that number is smaller than 20000000.</P>
<P>Validity check with the help of regular expressions requires we define a 
suitable regular expression. Then we can use the <CODE>matches</CODE> method of 
the class <CODE>String</CODE>, which checks whether the string matches with the 
regular expression in parameter. In the case of a student number, a suitable 
regular expression is <CODE>"01[0-9]{7}"</CODE>, and you can check the validity 
of what the user has input in the following way:</P>
<PRE class="sh_java">System.out.print("Give student number: ");
String num = reader.nextLine();

if (num.matches("01[0-9]{7}")) {
    System.out.println("The form is valid.");
} else {
    System.out.println("The form is not valid.");
}
</PRE>
<P>Next, we can go through the most commonly used regular expressions.</P>
<H4>Vertical Bar: Logical <EM>or</EM></H4>
<P>The vertical bar means that the parts of the regular expression are optional. 
For instance, the expression <CODE>00|111|0000</CODE> defines the strings 
<CODE>00</CODE>, <CODE>111</CODE> and <CODE>0000</CODE>. The method 
<CODE>matches</CODE> returns <CODE>true</CODE> if the string matches one of the 
alternatives defined.</P>
<PRE class="sh_java">    String string = "00";

    if(string.matches("00|111|0000")) {
        System.out.println("The string was matched by some of the alternatives");
    } else {
        System.out.println("The string not was matched by any of the alternatives");
    }
</PRE>
<PRE>The string was matched by some of the alternatives
</PRE>
<P>The regular expression <CODE>00|111|0000</CODE> requires the exactly same 
form of the string: its functionality is not like <EM>"contains"</EM>.</P>
<PRE class="sh_java">    String string = "1111";

    if(string.matches("00|111|0000")) {
        System.out.println("The string was matched by some of the alternatives");
    } else {
        System.out.println("The string not was matched by any of the alternatives");
    }
</PRE>
<PRE>The string not was matched by any of the alternatives
</PRE>
<H4>Round Brackets: a Delimited Part of the String</H4>
<P>With the help of round brackets it is possible to define what part of the 
regular expression is affected by the symbols. If we want to allow for the 
alternatives <CODE>00000</CODE> and <CODE>00001</CODE>, we can define it with 
the help of a vertical bar: <CODE>00000|00001</CODE>. Thanks to round brakers we 
can delimit the choice to only a part of the string. The expression 
<CODE>0000(0|1)</CODE> defines the strings <CODE>00000</CODE> and 
<CODE>00001</CODE>.</P>
<P>Accordingly, the regular expression <CODE>look(|s|ed)</CODE> defines the 
basic form of the verb to look (look), the third person (looks), and the past 
(looked).</P>
<PRE class="sh_java">System.out.print("Write a form of the verb to look: ");
String word = reader.nextLine();

if (word.matches("look(|s|ed|ing|er)")) {
    System.out.println("Well done!");
} else {
    System.out.println("Check again the form.");
}
</PRE>
<H4>Repetitions</H4>
<P>We often want to know whether a substring repeats within another string. In 
regular expressions, we can use repetition symbols:</P>
<UL>
  <LI>The symbol <STRONG><CODE>*</CODE></STRONG> stands for a repetition from 0 
  to n times, for instance<BR>
<PRE class="sh_java">    String string = "trolololololo";

    if(string.matches("trolo(lo)*")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</PRE>
<PRE>The form is right.
</PRE></LI>
  <LI>The symbol <STRONG><CODE>+</CODE></STRONG> stands for a repetition from 1 
  to n times, for instance<BR>
<PRE class="sh_java">    String string = "trolololololo";

    if(characterString.matches("tro(lo)+")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</PRE>
<PRE>The form is right.
</PRE>
<PRE class="sh_java">    String characterString = "nänänänänänänänä Bätmään!";

    if(characterString.matches("(nä)+ Bätmään!")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</PRE>
<PRE>The form is right.
</PRE></LI>
  <LI>The symbol <STRONG><CODE>?</CODE></STRONG> stands for a repetition of 0 or 
  1 time, for instance<BR>
<PRE class="sh_java">    String string = "You have accidentally the whole name";

    if(characterString.matches("You have accidentally (deleted )?the whole name")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</PRE>
<PRE>The form is right.
</PRE></LI>
  <LI>The symbol <STRONG><CODE>{a}</CODE></STRONG> stands for a repetition of 
  <CODE>a</CODE> times, for instance<BR>
<PRE class="sh_java">    String string = "1010";

    if(string.matches("(10){2}")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</PRE>
<PRE>The form is right.
</PRE></LI>
  <LI>The symbol <STRONG><CODE>{a,b}</CODE></STRONG> stands for a repetition 
  from <CODE>a</CODE> to <CODE>b</CODE> times, for instance<BR>
<PRE class="sh_java">    String string = "1";

    if(string.matches("1{2,4}")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</PRE>
<PRE>The form is wrong.
</PRE></LI>
  <LI>The symbol <STRONG><CODE>{a,}</CODE></STRONG> stands for a repetition from 
  <CODE>a</CODE> to n times, for instance<BR>
<PRE class="sh_java">    String string = "11111";

    if(string.matches("1{2,}")) {
        System.out.println("The form is right.");
    } else {
        System.out.println("The form is wrong.");
    }
</PRE>
<PRE>The form is right.
</PRE></LI></UL>
<P>You can also use various different repetition symbols within one regular 
expression. For instance, the regular expression <CODE>5{3}(1|0)*5{3}</CODE> 
defines strings which start and end with three fives. In between there can be an 
indefinite number of 1 and 0.</P>
<H4>Square Brackets: Character Groups</H4>
<P>With the help of square brackets we can quickly define groups of characters. 
The characters are written inside the brackets, and we can define an interval 
with the help of a hyphen (-). For instance, <CODE>[145]</CODE> means the same 
as <CODE>(1|4|5)</CODE>, whereas <CODE>[2-36-9]</CODE> means the same as 
<CODE>(2|3|6|7|8|9)</CODE>. Accordingly, <CODE>[a-c]*</CODE> defines a regular 
expression with a string made only of characters <CODE>a</CODE>, <CODE>b</CODE> 
and <CODE>c</CODE>.</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Regular Expressions</H3>
<P>Let's train to use regular expressions. The exercises are done in the 
<CODE>Main</CODE> class of the default package .</P>
<H4 class="req">Week Days</H4>
<P>Create the method <CODE>public static boolean isAWeekDay(String 
string)</CODE> in the class <CODE>Main</CODE>, using regular expressions. The 
method returns <CODE>true</CODE> if its parameter string is the abbreviation of 
a week day (mon, tue, wed, thu, fri, sat or sun).</P>
<P>The following is a sample print output of the method:</P>
<PRE>Give a string: <FONT color="red">tue</FONT>
The form is fine.
</PRE>
<PRE>Give a string: <FONT color="red">abc</FONT>
The form is wrong.
</PRE>
<H4 class="req">Vowel Inspection</H4>
<P>Create the method <CODE>public static boolean allVowels(String string)</CODE> 
in the class <CODE>Main</CODE>, which makes use of regular expressions and 
checks whether the String argument contains only vowel characters. </P>
<P>The following is a sample print output of the method:</P>
<PRE>Give a string: <FONT color="red">aie</FONT>
The form is fine.
</PRE>
<PRE>Give a string: <FONT color="red">ane</FONT>
The form is wrong.
</PRE>
<H4 class="req">Clock Time</H4>
<P>Regual expressions suit in particular situations. In some cases, the 
expressions become too complicate and it may be useful to check the "regularity" 
of a string in a different way, or it may be appropriate to use regular 
expressions to manage only a part of the inspection.</P>
<P>Create the method <CODE>public static boolean clockTime(String string)</CODE> 
in the class <CODE>Main</CODE>, which makes use of regular expressions and 
checks whether the String argument conforms with the clock time 
<CODE>hh:mm:ss</CODE> (two-digit hours, minutes, and seconds). In this exercise 
you can use whatever tecnique, in addition to regular expressions.</P>
<P>The following is a sample print output of the method:</P>
<PRE>Give a string: <FONT color="red">17:23:05</FONT>
The form is fine.
</PRE>
<PRE>Give a string: <FONT color="red">abc</FONT>
The form is wrong.
</PRE>
<PRE>Give a string: <FONT color="red">33:33:33</FONT>
The form is wrong.
</PRE></DIV></DIV>
<H3>Enum: Enumerated Type</H3>
<P>Previously, we implemented the class <CODE>Card</CODE> which represented a 
playing card:</P>
<PRE class="sh_java">public class Card {

    public static final int DIAMONDS = 0;
    public static final int SPADES = 1;
    public static final int CLUBS = 2;
    public static final int HEARTS = 3;

    private int value;
    private int suit;

    public Card(int value, int suit) {
        this.value = value;
        this.suit = suit;
    }

    @Override
    public String toString() {
        return suitName() + " "+value;
    }

    private String suitName() {
        if (suit == 0) {
            return "DIAMONDS";
        } else if (suit == 1) {
            return  "SPADES";
        } else if (suit == 2) {
            return "CLUBS";
        }
        return "HEARTS";
    }

    public int getSuit() {
        return suit;
    }
}
</PRE>
<P>The card suit is stored as object variable integer. Indicating the suit is 
made easier by constants which help the legibility. The constants which 
represent cards and suits are used in the following way:</P>
<PRE class="sh_java">public static void main(String[] args) {
        Card card = new Card(10, Card.HEARTS);

        System.out.println(card);

        if (card.getSuit() == Card.CLUBS) {
            System.out.println("It's clubs");
        } else {
            System.out.println("It's not clubs");
        }

}
</PRE>
<P>Representing the suit as a number is a bad solution, because the following 
absurd ways to use cards are possible:</P>
<PRE class="sh_java">        Card absurdCard = new Card(10, 55);

        System.out.println(absurdCard);

        if (absurdCard.getSuit() == 34) {
            System.out.println("The card's suit is 34");
        } else {
            System.out.println("The card's suit is not 34");
        }

        int suitPower2 = absurdCard.getSuit() * absurdCard.getSuit();

        System.out.println("The card's suit raised to the power of two is " + suitPower2);
</PRE>
<P>If we already know the possible values of our variables, we can use a 
<CODE>enum</CODE> class to represent them: an enumerated type. In addition to 
being classes and interfaces, enumerated types are also a class type of their 
own. Enumerated types are defined with the keyword <CODE>enum</CODE>. For 
instance the following <CODE>Suit</CODE> enum class defines four values: 
<CODE>DIAMONDS</CODE>, <CODE>SPADES</CODE>, <CODE>CLUBS</CODE> and 
<CODE>HEARTS</CODE>.</P>
<PRE class="sh_java">public enum Suit {
    DIAMONDS, SPADES, CLUBS, HEARTS
}
</PRE>
<P>In its most basic from, <CODE>enum</CODE> lists its constant values divided 
by a comma. Enum constants are usually written in capital letters.</P>
<P>Enums are usually created in their own file, in the same way as classes and 
interfaces. In Netbeans, you can create a enum by clicking to 
<EM>new/other/java/java enum</EM> on your project name. </P>
<P>The following <CODE>Card</CODE> class is represented with the help of 
enum:</P>
<PRE class="sh_java">public class Card {

    private int value;
    private Suit suit;

    public Card(int value, Suit suit) {
        this.value = value;
        this.suit = suit;
    }

    @Override
    public String toString() {
        return suit + " "+value;
    }

    public Suit getSuit() {
        return suit;
    }

    public int getValue() {
        return value;
    }
}
</PRE>
<P>The new version of the card is used in the following way:</P>
<PRE class="sh_java">public class Main {

    public static void main(String[] args) {
        Card first = new Card(10, Suit.HEARTS);

        System.out.println(first);

        if (first.getSuit() == Suit.CLUBS) {
            System.out.println("It's clubs");
        } else {
            System.out.println("It's not clubs");
        }

    }
}
</PRE>
<P>Prints:</P>
<PRE>HEARTS 10
It's not clubs
</PRE>
<P>We notice that enum names are printed smoothly! Because card suits' type is 
<CODE>Suit</CODE>, absurd practices like the one above -- raising a suit to the 
power of two -- do not work. Oracle has a tutorial for <CODE>enum</CODE> type at 
<A href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</A>.</P>
<H3>Iterator</H3>
<P>Let's have a look at the following class <CODE>Hand</CODE> which represents 
the cards a player has in his hand in a card game:</P>
<PRE class="sh_java">public class Hand {
    private ArrayList&lt;Card&gt; cards;

    public Hand() {
        cards = new ArrayList&lt;Hand&gt;();
    }

    public void add(Card card){
        cards.add(card);
    }

    public void print(){
        for (Card card : cards) {
            System.out.println( card );
        }
    }
}
</PRE>
<P>The <CODE>print</CODE> method prints each card in the hand by using a "for 
each" statement. ArrayList and other "object containers" which implement the 
<EM>Collection</EM> interface indirectly implement the interface 
<EM>Iterable</EM>. Objects which implement <EM>Iterable</EM> can be parses, or 
better "iterated", with statements such as for <EM>each</EM>.</P>
<P>Object containers can also be iterated using a so called <EM>iterator</EM>, 
that is an object, which was thought to parse a particular object collection. 
Below, there is a version of an iterator used to print cards:</P>
<PRE class="sh_java">public void print() {
    Iterator&lt;Card&gt; iterator = cards.iterator();

    while ( iterator.hasNext() ){
        System.out.println( iterator.next() );
    }
}
</PRE>
<P>The iterator is taken from the ArrayList <CODE>cards</CODE>. The iterator is 
like a finger, which always points out a specific object of the list, from the 
first to the second, to the third, and so on, till the finger has gone through 
each object.</P>
<P>The iterator provides a couple of methods. The method <CODE>hasNext()</CODE> 
asks whether there are still objects to be iterated. If there are, we can 
retrieve the following object using the method <CODE>next()</CODE>. The method 
returns the following object in the collection, and makes the iterator -- the 
"finger" -- point out the following object.</P>
<P>The object reference returned by the Iterator's next() method can be stored 
into a variable, of course; in fact, we could modify the method 
<CODE>print</CODE> in the following way:</P>
<PRE class="sh_java">public void print(){
    Iterator&lt;Card&gt; iterator = cards.iterator();

    while ( iterator.hasNext() ){
        Card nextCard = iterator.next();
        System.out.println( nextCard );
    }
}
</PRE>
<P>We can create a method to delete the cards which are smaller than a specific 
value:</P>
<PRE class="sh_java">public class Hand {
    // ...

    public void deleteWorst(int value) {
        for (Card card : cards) {
            if ( card.getValue() &lt; value ) {
                cards.remove(card);
            }
        }
    }
}
</PRE>
<P>We notice that running the method causes a strange error:</P>
<PRE>Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
        at java.util.AbstractList$Itr.next(AbstractList.java:343)
        at Hand.deleteWorst(Hand.java:26)
        at Main.main(Main.java:20)
Java Result: 1
</PRE>
<P>The reason is that you can't delete objects from a list while you are parsing 
it: the for each statement "gets all worked up".</P>
<P>If we want to delete a part of the objects while we parse our list, we have 
to use an iterator. If we call the <CODE>remove</CODE> method of our iterator 
object, we can neatly delete the value which was returned by the iterator with 
its previous <CODE>next</CODE> method call. The following method works fine:</P>
<PRE class="sh_java">public class Hand {
    // ...

    public void deleteWorst(int value) {
        Iterator&lt;Card&gt; iterator = cards.iterator();

        while (iterator.hasNext()) {
            if (iterator.next().getValue() &lt; value) {
                // delete the object returned by the iterator with its previous method call
                iterator.remove();
            }
        }
    }
}
</PRE>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Enum and Iterator</H3>
<P>Let's create a program to manage the staff personnel of a small business.</P>
<H4>Education</H4>
<P>Create the enumerated type, or enum, <CODE>Education</CODE> in the package 
<CODE>personnel</CODE>. The enum has the titles <CODE>D</CODE> (doctor), 
<CODE>M</CODE> (master), <CODE>B</CODE> (bachelor), <CODE>GRAD</CODE> 
(graduate).</P>
<H4>Person</H4>
<P>Create the class <CODE>Person</CODE> in <CODE>personnel</CODE>. Person is 
assigned a name and an education title as constructor parameters. Person has 
also a method to communicate their education, <CODE>public Education 
getEducation()</CODE>, as well as a <CODE>toString</CODE> method which returns 
the person information following the example below.</P>
<PRE class="sh_java">    Person arto = new Person("Arto", Education.D);
    System.out.println(arto);
</PRE>
<PRE>Arto, D
</PRE>
<H4>Employees</H4>
<P>Create the class <CODE>Employees</CODE> in <CODE>personnel</CODE>. An 
Employees object contains a list of Person objects. The class has a 
parameterless constructor plus the following methods:</P>
<UL>
  <LI><CODE>public void add(Person person)</CODE> adds the parameter person to 
  the employees</LI>
  <LI><CODE>public void add(List&lt;Person&gt; persons)</CODE> adds the 
  parameter list of people to the employees</LI>
  <LI><CODE>public void print()</CODE> prints all the employees</LI>
  <LI><CODE>public void print(Education education)</CODE> prints all the 
  employees, who have the same education as the one specified as 
parameter</LI></UL>
<P><STRONG>ATTENTION:</STRONG> The <CODE>Print</CODE> method of the class 
<CODE>Employees</CODE> have to be implemented using an iterator!</P>
<H4>Firing</H4>
<P>Create the method <CODE>public void fire(Education education)</CODE> in the 
class <CODE>Employees</CODE>. The method deletes all the employees whose 
education is the same as the method argument.</P>
<P><STRONG>ATTENTION:</STRONG> implement the method using an iterator!</P>
<P>Below, you find an example of the class usage:</P>
<PRE class="sh_java">public class Main {

    public static void main(String[] args) {
        Employees university = new Employees();
        university.add(new Person("Matti", Education.D));
        university.add(new Person("Pekka", Education.GRAD));
        university.add(new Person("Arto", Education.D));

        university.print();

        university.fire(Education.GRAD);

        System.out.println("==");

        university.print();
}
</PRE>
<P>Prints:</P>
<PRE>Matti, D
Pekka, GRAD
Arto, D
==
Matti, D
Arto, D
</PRE></DIV></DIV>
<H3>Loops and continue</H3>
<P>In addition to the <CODE>break</CODE> statement, loops have also got the 
<CODE>continue</CODE> statement, which allows you to skip to the following loop 
stage.</P>
<PRE class="sh_java">    List&lt;String&gt; names = Arrays.asList("Matti", "Pekka", "Arto");

    for(String name: names) {
        if (name.equals("Arto")) {
            continue;
        }

        System.out.println(name);
    }
</PRE>
<PRE>Matti
Pekka
</PRE>
<P>The <CODE>continue</CODE> statement is used especially when we know the 
iterable variables have got values with which we do not want to handle at all. 
The classic manner of approach would be using an if statement, but the 
<CODE>continue</CODE> statement allows for another approach to handle with the 
values, which avoids indentations and possibly helps readability. Below, you 
find two examples, where we go through the numbers of a list. If the number is 
smaller than 5 and contains 100, or if it contains 40, it is not printed; 
otherwise it is.</P>
<PRE class="sh_java">    List&lt;Integer&gt; values = Arrays.asList(1, 3, 11, 6, 120);

    for(int num: values) {
        if (num &gt; 4 &amp;&amp; num % 100 != 0 &amp;&amp; num % 40 != 0) {
            System.out.println(num);
        }
    }

    for(int num: values) {
        if (num &lt; 5) {
            continue;
        }

        if (num % 100 == 0) {
            continue;
        }

        if (num % 40 == 0) {
            continue;
        }

        System.out.println(num);
    }
</PRE>
<PRE>11
6
11
6
</PRE>
<H3>More about Enums</H3>
<P>Next, we create enums which contain object variables and implement an 
interface.</P>
<H4>Enumerated Type Constructor Parameters</H4>
<P>Enumerated types can contain object variables. Object variable values have to 
be set up in the constructor of the class defined by enumerated type. Enum-type 
classes cannot have <CODE>public</CODE> constructors.</P>
<PRE class="sh_java">public enum Colour {
    RED("red"), // the constructor parameters are defined as constant values when they are read
    GREEN("green"),
    BLUE("blue");

    private String name; // object variable

    private Colour(String name) { // constructor
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
}
</PRE>
<P>The enumerated value <CODE>Colour</CODE> can be used in the following 
way:</P>
<PRE class="sh_java">    System.out.println(Colour.GREEN.getName());
</PRE>
<PRE>green
</PRE>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Film Reference</H3>
<P>Recently, in October 2006 after arriving to Finland, <A href="https://signup.netflix.com/" 
target="_blank">Netflix</A> promised one million dollars to the person or group 
of people who developed a program, which would be 10% better than their own 
program. The challenge was met September 2009 (<A href="http://www.netflixprize.com/" 
target="_blank">http://www.netflixprize.com/</A>).</P>
<P>With this exercise, we create a program to recommend films. Below, you see 
how it should work:</P>
<PRE class="sh_java">    EvaluationRegister ratings = new EvaluationRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, theBridgesOfMadisonCounty, Rating.BAD);
    ratings.addRating(pekka, eraserhead, Rating.MEDIOCRE);

    ratings.addRating(mikke, eraserhead, Rating.GOOD);


    Reference reference = new Reference(votes);
    System.out.println(thomas + "'s recommendation: " +
            reference.recommendFilm(thomas));
    System.out.println(mikke + "'s recommendation: " +
            reference.recommendFilm(mikke));
</PRE>
<PRE>Thomas's recommendation: The Bridges of Madison County
Mikke's recommendation: Gone with the Wind
</PRE>
<P>The program is able to recommend films both according to their common 
appraisal and according to the ratings given by a specific person. Let's start 
to build our program.</P>
<H4>Person and Film</H4>
<P>Create the package <CODE>reference.domain</CODE>, and there you add the 
classes <CODE>Person</CODE> and <CODE>Film</CODE>. Both classes have a public 
constructor <CODE>public <EM>Class</EM>(String name)</CODE>, as well as the 
method <CODE>public String getName()</CODE>, which returns the name received 
with the argument.</P>
<PRE class="sh_java">    Person p = new Person("Pekka");
    Film f = new Film("Eraserhead");

    System.out.println(p.getName() + " and " + f.getName());
</PRE>
<PRE>Pekka and Eraserhead
</PRE>
<P>Also add the method <CODE>public String toString()</CODE> which returns the 
name received with the argument, as well as the method <CODE>equals</CODE> and 
<CODE>hashCode</CODE>.</P>
<P>Override <CODE>equals</CODE> so that the equivalence is checked according to 
the object variable <CODE>name</CODE>. Look at the example in section 45.1. In 
Section 45.2 there are guidelines to override <CODE>hashCode</CODE> methods. At 
least, you'd better generate the HashCode automatically, following the 
instructions at the end of the section:</P>
<P><EM>NetBeans allows for the automatic creation of the <CODE>equals</CODE> and 
<CODE>hashCode</CODE> methods. From the menu Source -&gt; Insert Code, you can 
choose <EM>equals() and hashCode()</EM>. After this, NetBeans asks which object 
variables the methods shall use.</EM> </P>
<P><STRONG>Attention:</STRONG> to help finding mistakes, you may want to 
implement toString methods to Person and Film, but the tests do not require 
them.</P>
<H4>Rating</H4>
<P>Create the enumerated type <CODE>Rating</CODE> in 
<CODE>reference.domain</CODE>. The enum class <CODE>Rating</CODE> has a public 
method <CODE>public int getValue()</CODE>, which returns the value of the 
rating. The value names and their grades have to be the following:</P>
<P></P>
<TABLE style="padding-left: 2em;">
  <TBODY>
  <TR>
    <TH>Rating</TH>
    <TH>Value</TH></TR>
  <TR>
    <TD>BAD</TD>
    <TD>-5</TD></TR>
  <TR>
    <TD>MEDIOCRE</TD>
    <TD>-3</TD></TR>
  <TR>
    <TD>NOT_WATCHED</TD>
    <TD>0</TD></TR>
  <TR>
    <TD>NEUTRAL</TD>
    <TD>1</TD></TR>
  <TR>
    <TD>FINE</TD>
    <TD>3</TD></TR>
  <TR>
    <TD>GOOD</TD>
    <TD>5</TD></TR></TBODY></TABLE>
<P>The class could be used in the following way:</P>
<PRE class="sh_java">    Rating given = Rating.GOOD;
    System.out.println("Rating " + given + ", value " + given.getValue());
    given = Rating.NEUTRAL;
    System.out.println("Rating " + given + ", value " + given.getValue());
</PRE>
<PRE>Rating GOOD, value 5
Rating NEUTRAL, value 1
</PRE>
<H4>RatingRegister, Part 1</H4>
<P>Let's get started with the implementation necessary to store the ratings.</P>
<P>Create the class <CODE>RatingRegister</CODE> in the package 
<CODE>reference</CODE>; the class has the constructor <CODE>public 
RatingRegister()</CODE>, as well as the following methods:</P>
<UL>
  <LI><CODE>public void addRating(Film film, Rating rating)</CODE> adds a new 
  rating to the parameter film. The same film can have various same 
ratings.</LI>
  <LI><CODE>public List&lt;Rating&gt; getRatings(Film film)</CODE> returns a 
  list of the ratings which were added in connection to a film.</LI>
  <LI><CODE>public Map&lt;Film, List&lt;Rating&gt;&gt; filmRatings()</CODE> 
  returns a map whose keys are the evaluated films. Each film is associated to a 
  list containing the ratings for that film.</LI></UL>
<P>Test the methods with the following source code:</P>
<PRE class="sh_java">    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    RatingRegister reg = new RatingRegister();
    reg.addRating(eraserhead, Rating.BAD);
    reg.addRating(eraserhead, Rating.BAD);
    reg.addRating(eraserhead, Rating.GOOD);

    reg.addRating(theBridgesOfMadisonCounty, Rating.GOOD);
    reg.addRating(theBridgesOfMadisonCounty, Rating.FINE);

    System.out.println("All ratings: " + reg.filmRatings());
    System.out.println("Ratings for Eraserhead: " + reg.getRatings(eraserhead));
</PRE>
<PRE>All ratings: {The Bridges of Madison County=[GOOD, FINE], Eraserhead=[BAD, BAD, GOOD]}
Ratings for Eraserhead: [BAD, BAD, GOOD]
</PRE>
<H4>RatingRegister, Part 2</H4>
<P>Let's make possible to add personal ratings.</P>
<P>Add the following methods to the class <CODE>RatingRegister</CODE>:</P>
<UL>
  <LI><CODE>public void addRating(Person person, Film film, Rating 
  rating)</CODE> adds the rating of a specific film to the parameter person. The 
  same person can recommend a specific film only once. The person rating has 
  also to be added to the ratings connected to all the films.</LI>
  <LI><CODE>public Rating getRating(Person person, Film film)</CODE> returns the 
  rating the paramater person has assigned to the parameter film. If the person 
  hasn't evaluated such film, the method returns 
  <CODE>Rating.NOT_WATCHED</CODE>.</LI>
  <LI><CODE>public Map&lt;Film, Rating&gt; getPersonalRatings(Person 
  person)</CODE> returns a HashMap which contains the person's ratings. The 
  HashMap keys are the evaluated films, and their values are the ratings of 
  these films.</LI>
  <LI><CODE>public List&lt;Person&gt; reviewers()</CODE> returns a list of the 
  people who have evaluate the films.</LI></UL>
<P>People's ratings should be stored into a HashMap, and the people should act 
as keys. The values of the HashMap is another HashMap, whose keys are films and 
whose values are ratings.</P>
<P>Test your improved <CODE>RatingRegister</CODE> with the following source 
code:</P>
<PRE class="sh_java">    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.GOOD);
    ratings.addRating(pekka, eraserhead, Rating.GOOD);

    System.out.println("Ratings for Eraserhead: " + ratings.getRatings(eraserhead));
    System.out.println("Matti's ratings: " + ratings.getPersonalRatings(matti));
    System.out.println("Reviewers: " + ratings.reviewers());
</PRE>
<PRE>Ratings for Eraserhead: [FINE, GOOD]
Matti's ratings: {Gone with the Wind=BAD, Eraserhead=FINE}
Reviewers: [Pekka, Matti]
</PRE>
<P>Next, we create a couple of helping classes to help evaluation.</P>
<H4>PersonComparator</H4>
<P>Create the class <CODE>PersonComparator</CODE> in the package 
<CODE>reference.comparator</CODE>. The class <CODE>PersonComparator</CODE> has 
to implement the interface <CODE>Comparator&lt;Person&gt;</CODE>, and it has to 
have the constructor <CODE>public PersonComparator(Map&lt;Person, Integer&gt; 
peopleIdentities)</CODE>. The class <CODE>PersonComparator</CODE> is used later 
on to sort people according to their number.</P>
<P>Test the class with the following source code:</P>
<PRE class="sh_java">    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    Map&lt;Person, Integer&gt; peopleIdentities = new HashMap&lt;Person, Integer&gt;();
    peopleIdentities.put(matti, 42);
    peopleIdentities.put(pekka, 134);
    peopleIdentities.put(mikke, 8);
    peopleIdentities.put(thomas, 82);

    List&lt;Person&gt; ppl = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("People before sorting: " + ppl);

    Collections.sort(ppl, new PersonComparator(peopleIdentities));
    System.out.println("People after sorting: " + ppl);
</PRE>
<PRE>People before sorting: [Matti, Pekka, Mikke, Thomas]
People after sorting: [Pekka, Thomas, Matti, Mikke]
</PRE>
<H4>FilmComparator</H4>
<P>Create the class <CODE>FilmComparator</CODE> in the package 
<CODE>reference.comparator</CODE>. The class <CODE>FilmComparator</CODE> has to 
implement the interface <CODE>Comparator&lt;Film&gt;</CODE>, and it has to have 
the constructor <CODE>public FilmComparator(Map&lt;Film, List&lt;Rating&gt;&gt; 
ratings)</CODE>. The class <CODE>FilmComparator</CODE> will be used later on to 
sort films according to their ratings.</P>
<P>The class FilmComparator has to allow for film sorting according to the 
average of the rating values they have received. The films with the greatest 
average should be placed first, and the ones with the smallest average should be 
the last.</P>
<P>Test the class with the following source code:</P>
<PRE class="sh_java">    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, theBridgesOfMadisonCounty, Rating.BAD);
    ratings.addRating(pekka, eraserhead, Rating.MEDIOCRE);

    ratings.addRating(mikke, eraserhead, Rating.BAD);

    Map&lt;Film, List&lt;Rating&gt;&gt; filmRatings = ratings.filmRatings();

    List&lt;Film&gt; films = Arrays.asList(goneWithTheWind, theBridgesOfMadisonCounty, eraserhead);
    System.out.println("The films before sorting: " + films);

    Collections.sort(films, new FilmComparator(filmRatings));
    System.out.println("The films after sorting: " + films);
</PRE>
<PRE>The films before sorting: [Gone with the Wind, The Bridges of Madison County, Eraserhead]
The films after sorting: [The Bridges of Madison County, Gone with the Wind, Eraserhead]
</PRE>
<H4>Reference, Part 1</H4>
<P>Implement the class <CODE>Reference</CODE> in the package 
<CODE>reference</CODE>. The class <CODE>Reference</CODE> receives a 
<CODE>RatingRegister</CODE> object as constructor parameter. Reference uses the 
ratings in the rating register to elaborate a recommendation.</P>
<P>Implement the method <CODE>public Film recommendFilm(Person person)</CODE>, 
which implements films to people. Hint: you need three things to find out the 
most suitable film. These are at least the class <CODE>FilmComparator</CODE> 
which you created earlier on; the method <CODE>public Map&lt;Film, 
List&lt;Rating&gt;&gt; filmRatings()</CODE> of the class 
<CODE>RatingRegister</CODE>; and a list of the existing films.</P>
<P>Test your program with the following source code:</P>
<PRE class="sh_java">    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, theBridgesOfMadisonCounty, Rating.BAD);
    ratings.addRating(pekka, eraserhead, Rating.MEDIOCRE);

    Reference ref = new Reference(ratings);
    Film recommended = ref.recommendFilm(mikke);
    System.out.println("The film recommended to Michael is: " + recommended);
</PRE>
<PRE>The film recommended to Michael is: The Bridges of Madison County
</PRE>
<P>Now, our first part works fine exclusively for people who have never 
evaluated any movie. In such cases, we can't say anything about their film 
tastes, and the best choice is recommending them the film which has received the 
hightest average among the ratings.</P>
<H4>Reference, Part 2</H4>
<P><EM>Attention! The exercise is challenging. First you should do the previous 
exercises and coming back to this one later. You can return the sequence of 
exercises in TMC; even though you don't get the point for this part, you'd get 
the points for the perious ones, as it is with all the exercises.</EM></P>
<P>Unfortunately, the error diagnostics of this part is not similar to the 
previous parts.</P>
<P>If people have added their own preferences to the reference service, we know 
something about their film tastes. Let's extend the functionality of our 
reference to create a personal recommendation if the person has evaluated films. 
The functionality implemented in the previous part has to be preserved: if a 
person hasn't evaluated any film, we recommend them a film according to film 
ratings.</P>
<P>Personal recommendations are based on the similarity between the person 
ratings and other people's ratings. Let's reason about it with the help of the 
following table; in the first line on the top there are films, and the people 
who have rated are on the left. The brackets describe the ratings given.</P>
<P></P>
<TABLE style="padding-left: 2em;">
  <TBODY>
  <TR>
    <TH>Person \ Film</TH>
    <TD>Gone with the Wind</TD>
    <TD>The Bridges of Madison County</TD>
    <TD>Eraserhead</TD>
    <TD>Blues Brothers</TD></TR>
  <TR>
    <TD>Matti</TD>
    <TD>BAD (-5)</TD>
    <TD>GOOD (5)</TD>
    <TD>FINE (3)</TD>
    <TD>-</TD></TR>
  <TR>
    <TD>Pekka</TD>
    <TD>FINE (3)</TD>
    <TD>-</TD>
    <TD>BAD (-5)</TD>
    <TD>MEDIOCRE (-3)</TD></TR>
  <TR>
    <TD>Mikael</TD>
    <TD>-</TD>
    <TD>-</TD>
    <TD>BAD (-5)</TD>
    <TD>-</TD></TR>
  <TR>
    <TD>Thomas</TD>
    <TD>-</TD>
    <TD>GOOD (5)</TD>
    <TD>-</TD>
    <TD>GOOD (5)</TD></TR></TBODY></TABLE>
<P>If we want to find the suitable film for Mikael, we can explore the 
similarity between Mikael's and other people's preferences. The similarity is 
calculated based on the ratings: as the sum of the products of the ratings for 
the films watched by both. For instance, Mikael and Thomas's similarity is 0, 
because they haven't watched the same films.</P>
<P>If we calculate Mikael and Pekka's similarity, we find out that the sum of 
the products of the films they have in common is 25. Mikael and Pekka have both 
watched only one film, and they have both given it the grade bad (-5).</P>
<PRE>-5 * -5 = 25
</PRE>
<P>Mikael and Matti's similarity is -15. Mikael and Matti have also watched only 
one same film. Mikael gave the grade bad (-5) to the film, whereas Matti gave it 
the grade fine (3).</P>
<PRE>-5 * 3 = -15
</PRE>
<P>Based on that Mikael can be recommended films according to Pekka's taste: the 
recommendation is Gone with the Wind.</P>
<P>On the other hand, if we want to find a suitable film for Matti, we have to 
find the similarity between Matti and everyone else. Matti and Pekka have 
watched two same films. Matti gave Gone with the Wind the grade bad (-5), Pekka 
the grade fine (3). Matti gave fine (3) to Eraserhead, and Pekka gave bad (-5). 
Matti and Pekka's similarity is -30.</P>
<PRE>-5 * 3 + 3 * -5 = -30
</PRE>
<P>Matti and Mikael's similarity is -15, which we know according to out previous 
calculations. Similarities are symmetrical.</P>
<P>Matti and Thomas have watched Gone with the Wind, and they both gave it the 
grade good (5). Matti and Thomas's similarity is 25, then.</P>
<PRE>5 * 5 = 25
</PRE>
<P>Matti has to be recommended a film according to Thomas' taste: the 
recommendation will be the Blues Brothers.</P>
<P>Implement the recommendation mechanism described above. The method 
<CODE>recommendFilm</CODE> should return <CODE>null</CODE> in two cases: if you 
cannot find any film to recommend; if you find a, say, person1 whose film taste 
is appropriate to recommend films to, say, person2, but person1 has rated bad, 
mediocre, or neutral, all the films person2 hasn't watched, yet. The approach 
described above has to work also if the person hasn't added any rating.</P>
<P>Do not suggest films which have already been watched.</P>
<P>You can test your program with the following source code:</P>
<PRE class="sh_java">    RatingRegister ratings = new RatingRegister();

    Film goneWithTheWind = new Film("Gone with the Wind");
    Film theBridgesOfMadisonCounty = new Film("The Bridges of Madison County");
    Film eraserhead = new Film("Eraserhead");
    Film bluesBrothers = new Film("Blues Brothers");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");
    Person thomas = new Person("Thomas");
    Person arto = new Person("Arto");

    ratings.addRating(matti, goneWithTheWind, Rating.BAD);
    ratings.addRating(matti, theBridgesOfMadisonCounty, Rating.GOOD);
    ratings.addRating(matti, eraserhead, Rating.FINE);

    ratings.addRating(pekka, goneWithTheWind, Rating.FINE);
    ratings.addRating(pekka, eraserhead, Rating.BAD);
    ratings.addRating(pekka, bluesBrothers, Rating.MEDIOCRE);

    ratings.addRating(mikke, eraserhead, Rating.BAD);

    ratings.addRating(thomas, bluesBrothers, Rating.GOOD);
    ratings.addRating(thomas, theBridgesOfMadisonCounty, Rating.GOOD);

    Reference ref = new Reference(ratings);
    System.out.println(thomas + " recommendation: " + ref.recommendFilm(thomas));
    System.out.println(mikke + " recommendation: " + ref.recommendFilm(mikke));
    System.out.println(matti + " recommendation: " + ref.recommendFilm(matti));
    System.out.println(arto + " recommendation: " + ref.recommendFilm(arto));
</PRE>
<PRE>Thomas recommendation: Eraserhead
Mikael recommendation: Gone with the Wind
Matti recommendation: Blues Brothers
Arto recommendation: The Bridges of Madison County
</PRE>
<P>Have we made one million bucks? Not yet, maybe. In the course Introduction to 
Artificial Intelligence and Machine Learning we learn more techniques to build 
learning programs.</P></DIV></DIV>
<H3>Variable Number of Method Parameters</H3>
<P>So far, we have been creating methods which had a clearly defined number of 
parameters. Java makes it possible to give an indefinite number of a specific 
type of parameters by placing an ellipsis after the parameter type. For instance 
the method <CODE>public int sum(int... values)</CODE> can be given as parameter 
as many integers (<CODE>int</CODE>) as the user wants. The parameter values can 
be handled as a table.</P>
<PRE class="sh_java">    public int sum(int... values) {
        int sum = 0;
        for (int i = 0; i &lt; values.length; i++) {
            sum += values[i];
        }
        return sum;
    }
</PRE>
<PRE class="sh_java">    System.out.println(sum(3, 5, 7, 9));  // values = {3, 5, 7, 9}
    System.out.println(sum(1, 2));        // values = {1, 2}
</PRE>
<PRE>24
3
</PRE>
<P>Note that the parameter definition above <CODE>int... values</CODE> depends 
on the fact that the method has a table-like variable called 
<CODE>values</CODE>.</P>
<P>A method can be assigned only one parameter which receives an indefinite 
number of values, and this must be the first parameter in the method definition. 
For instance:</P>
<PRE class="sh_java">    public void print(String... characterStrings, int times) // right!
    public void print(int times, String... strings) // wrong!
</PRE>
<P>An indefinite number of parameter values is used for instance when we want to 
create an interface which would not force the user to use a precise number of 
parameters. An alternative approach would be defining a list of that precise 
type as parameter. In this case, the objects can be assigned to the list before 
the method call, and the method can be called and given the list as 
parameter.</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Flexible Filtering Criteria</H3>
<P>In some exercises (see Library in Introduction to Programming, and Word 
Inspection in Advanced Programming), we have run into such situations where we 
had to filter out list objects according to particular criteria; for instance, 
in Word Inspection the methods <CODE>wordsContainingZ, wordsEndingInL, 
palindromes, wordsWhichContainAllVowels</CODE> all to the same same thing: they 
go through the file content one word after the other, and they make sure that 
the specific filtering criteria are satisfied, in which case they store the 
word. Because the method criteria are different, we haven't been able to get rid 
of this repetition, and the code of all those methods made wide use of 
copypaste.</P>
<P>With this exercise, we create a program to filter the lines of the books 
found on the <A 
href="http://mooc.cs.helsinki.fi/programming-part2/material/">Project 
Guttenberg</A> pages. In the following example we analyze Dostojevski's Crime 
and Punishment. We want to have various different filtering criteria, and that 
it would be possible to filter according to different criteria combinations. The 
program structure should also allow for adding new criteria later on.</P>
<P>A suitable solution to the problem, is defining the filtering criteria as 
objects of their own which implement the interface <CODE>Criterion</CODE>. The 
interface definition is below:</P>
<PRE class="sh_java">public interface Criterion {
    boolean complies(String line);
}
</PRE>
<P>A filtering class which implements the interface:</P>
<PRE class="sh_java">public class ContainsWord implements Criterion {

    String word;

    public ContainsWord(String word) {
        this.word = word;
    }

    @Override
    public boolean complies(String line) {
        return line.contains(word);
    }
}
</PRE>
<P>The class objects are quite simple, in fact, and they only remember the word 
given as constructor parameter. The only method of the object can be asked 
whether the criterion complies to the parameter String; if so, this means that 
the object contains the word stored into the String object.</P>
<P>Together with the excercise body, you find the pre-made class 
<CODE>GutenbergReader</CODE>, which helps you to analyze book lines according to 
the filtering criteria given as parameter:</P>
<PRE class="sh_java">public class GutenbergReader {

    private List&lt;String&gt; lines;

    public GutenbergReader(String address) throws IllegalArgumentException {
        // the code which retrieves the book from the Internet
    }

    public List&lt;String&gt; linesWhichComplyWith(Criterion c){
        List&lt;String&gt; complyingLines = new ArrayList&lt;String&gt;();

        for (String line : lines) {
            if (c.complies(line)) {
                complyingLines.add(line);
            }
        }

        return complyingLines;
    }
}
</PRE>
<P>With the following code, we print all the lines in Crime and Punishment which 
contain the word "beer":</P>
<PRE class="sh_java">public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new ContainsWord("beer");

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</PRE>
<H4>All Lines</H4>
<P>Create the class <CODE>AllLines</CODE> which implements 
<CODE>Criterion</CODE>, which accepts all the lines. This and the other classes 
of the exercise have to be implemented in the package 
<CODE>reader.criteria</CODE>.</P>
<PRE class="sh_java">public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new AllLines();

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</PRE>
<H4>Ends with Question or Exclamation Mark</H4>
<P>Implement class <CODE>EndsWithQuestionOrExclamationMark</CODE>, which 
implements the interface <CODE>Criterion</CODE> and accepts the lines whose last 
character is a question or an exclamation mark.</P>
<PRE class="sh_java">public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

     Criterion criterion = new EndsWithQuestionOrExclamationMark();

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</PRE>
<P><STRONG>Reminder:</STRONG> you compare character in Java with the == 
operator:</P>
<PRE class="sh_java">String name = "pekka";

// ATTENTION: 'p' is a character, that is to say char p; differently, "p" is a String, whose only character is p
if ( name.charAt(0) == 'p' ) {
    System.out.println("beginning with p");
} else {
    System.out.println("beginning with something else than p");
}
</PRE>
<H4>Length At Least</H4>
<P>Implement the class <CODE>LengthAtLeast</CODE>, which implements the 
interface <CODE>Criterion</CODE> and accepts the lines whose length is equal or 
greater than the number received as constructor parameter.</P>
<PRE class="sh_java">public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

     Criterion criterion = new LengthAtLeast(40);

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</PRE>
<H4>Both</H4>
<P>Create the class <CODE>Both</CODE> which implements the interface 
<CODE>Criterion</CODE>. The objects of this class receive two objects as 
constructor parameter, both implementing the interface <CODE>Criterion</CODE>. 
<CODE>Both</CODE> objects accept the lines which comply with both the criteria 
received as constructor parameters. We print below all the lines which end with 
a question or an exclamation mark and that contain the word "beer". </P>
<PRE class="sh_java">public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new Both(
                    new EndsWithQuestionOrExclamationMark(),
                    new ContainsWord("beer")
                );

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</PRE>
<H4>Negation</H4>
<P>Create the class <CODE>Not</CODE> which implement the interface 
<CODE>Criterion</CODE> and accepts the lines, which don't comply with the 
criterion received as parameter. We print below the lines whose length is less 
than 10. </P>
<PRE class="sh_java">public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion = new Not( new LengthAtLeast(10) );

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</PRE>
<H4>At Least One</H4>
<P>Create the class <CODE>AtLeastOne</CODE> which implements the interface 
<CODE>Criterion</CODE>. The objects of this class receive as parameter an 
optional amount of objects which implement the interface <CODE>Criterion</CODE>; 
this means that the constructor receives a list of variable length as parameter. 
<CODE>AtLeastOne</CODE> objects accept the lines which comply with at least one 
of the criteria received as constructor parameter. We print below the lines 
which contain one ot the words "beer", "milk" or "oil". </P>
<PRE class="sh_java">public static void main(String[] args) {
    String address = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergReader book = new GutenbergReader(address);

    Criterion criterion =new AtLeastOne(
                    new ContainsWord("beer"),
                    new ContainsWord("milk"),
                    new ContainsWord("oil")
                );

    for (String line : book.linesWhichComplyWith(criterion)) {
        System.out.println(line);
    }
}
</PRE>
<P>Note that the criteria can be combined as preferred. You find below a 
criterion which accepts the lines which have at least one of the words "beer", 
"milk" and "oil" and whose length is between 20-30 characters.</P>
<PRE class="sh_java">    Criterion words = new AtLeastOne(
                    new ContainsWord("beer"),
                    new ContainsWord("milk"),
                    new ContainsWord("oil")
                );

    Criterion rightLength = new Both(
                         new LengthAtLeast(20),
                         new Not( new LengthAtLeast(31))
                       );

    Criterion wanted = new Both(words, rightLength);
</PRE></DIV></DIV>
<H3>StringBuilder</H3>
<P>We have got accustomed to building strings in the following way:</P>
<PRE class="sh_java">    public static void main(String[] args) {
        int[] t = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(build(t));
    }

    public static String build(int[] t) {
        String str = "{";

        for (int i = 0; i &lt; t.length; i++) {
            str += t[i];
            if (i != t.length - 1) {
                str += ", ";

            }
        }

        return str + "}";
    }
</PRE>
<P>Result:</P>
<PRE>{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
</PRE>
<P>This works, but it could be more effective. As we remember, strings are 
<EM>immutable</EM> objects. The result of a String operation is always a new 
String object. This means that in the interphases of previous example 10 String 
objects were created. If the dimension of the input was bigger, creating new 
objects in the various interphases would start to have an unpleasant impact on 
the program execution time.</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>String builder</H3>
<P>In situations like the previous one, it is better to use 
<CODE>StringBuilder</CODE> objects when it comes to building strings. 
Differently from Strings, StringBuilders are not immutable, meaning 
StringBuilder-objects can be modified. Get acquainted with the description of 
the StringBuilder API (you'll find it by googling "stringbuilder java api 6") 
and modify the method in the exercise body, <CODE>public static String 
build(int[] t)</CODE>, so that it would use StringBuilder and work in the 
following way:</P>
<PRE>{
1, 2, 3, 4,
5, 6, 7, 8,
9, 10
}
  </PRE>
<P>The curly brackets are on their own lines. There are up to four values in 
each line of the table, and the first value requires an initial space. Before 
each number, and after the comma there must be exactly one 
space.</P></DIV></DIV>
<H2>Grande Finale</H2>
<P>The course is nearing the end, and it's time for the grande finale!</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Worm Game</H3>
<P>In this exercise, we create the structure and functionality for the following 
worm game. Unlike in the picture   below, our worm game will be coloured 
differently: worm is black, apple is red and background is gray.</P>
<P><IMG src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/snakegame.png"></P>
<H4>Piece and Apple</H4>
<P>Create the class <CODE>Piece</CODE> in <CODE>wormgame.domain</CODE>. The 
class <CODE>Piece</CODE> has the constructor <CODE>public Piece(int x, int 
y)</CODE>, which receives the position of the piece as parameter. Moreover, the 
class <CODE>Piece</CODE> has the following methods.</P>
<UL>
  <LI><CODE>public int getX()</CODE> returns the x coordinate of the piece, 
  which was assigned in the constructor.</LI>
  <LI><CODE>public int getY()</CODE> returns the y coordinate of the piece, 
  which was assigned in the constructor.</LI>
  <LI><CODE>public boolean runsInto(Piece piece)</CODE> returns true if the 
  object has the same coordinates as the Piece instance received as 
  paramater.</LI>
  <LI><CODE>public String toString()</CODE> returns the piece position following 
  the pattern <CODE>(x,y)</CODE>. For instance. <CODE>(5,2)</CODE> if the value 
  of x is 5 and the value of y is 2.</LI></UL>
<P>Also implement the class <CODE>Apple</CODE> in <CODE>wormgame.domain</CODE>, 
and let Apple inherit <CODE>Piece</CODE>.</P>
<H4>Worm </H4>
<P>Implement the class <CODE>Worm</CODE> in the package 
<CODE>wormgame.domain</CODE>. The class <CODE>Worm</CODE> has the constructor 
<CODE>public Worm(int originalX, int originalY, Direction 
originalDirection)</CODE>, which creates a new worm whose direction is the 
parameter <CODE>originalDirection</CODE>. Worm is composed of a list of 
instances of the class <CODE>Piece</CODE>. Attention: the pre-made enum 
<CODE>Direction</CODE> can be found in the package <CODE>wormgame</CODE>.</P>
<P>When it's created, Worm's length is one, but its "mature" length is three. 
Worm has to grow by one piece while it moves. When its length is three, Worm 
grows only by eating.</P>
<P>Implement the following methods</P>
<UL>
  <LI><CODE>public Direction getDirection()</CODE> return's Worm's 
  direction.</LI>
  <LI><CODE>public void setDirection(Direction dir)</CODE> sets a new direction 
  for the worm. The worm starts to move in the new direction when the method 
  <CODE>move</CODE> is called again.</LI>
  <LI><CODE>public int getLength()</CODE> returns the Worm's length. The Worm's 
  length has to be equal to the length of the list returned by the method 
  <CODE>getPieces()</CODE>.</LI>
  <LI><CODE>public List&lt;Piece&gt; getPieces()</CODE> returns a list of Piece 
  objects which the worm is composed of. The pieces in the list are in order, 
  with the worm head at the end of the list.</LI>
  <LI><CODE>public void move()</CODE> moves the worm one piece forward.</LI>
  <LI><CODE>public void grow()</CODE> grows the worm by one piece. The worm 
  grows together with the following <CODE>move</CODE> method call; after the 
  first move method call the worm does not grow any more.</LI>
  <LI><CODE>public boolean runsInto(Piece piece)</CODE> checks whether the worm 
  runs into the parameter piece. If so -- that is, if a piece of the worm runs 
  into the parameter piece -- the method returns the value <CODE>true</CODE>; 
  otherwise it returns <CODE>false</CODE>.</LI>
  <LI><CODE>public boolean runsIntoItself()</CODE> check whether the worm runs 
  into itself. If so -- that is, if one of the worm's pieces runs into another 
  piece -- the method returns the value <CODE>true</CODE>. Otherwise it returns 
  <CODE>false</CODE>.</LI></UL>
<P>The functionality of <CODE>public void grow()</CODE> and <CODE>public void 
move()</CODE> has to be implemented so that the worm grows only with the 
following move.</P>
<P>Motion should be implemented in a way that the worm is always given a new 
piece. The position of the new piece depends on the moving direction: if moving 
left, the new piece location should on the left of the head piece, i.e. the x 
coordinate of the head should be smaller by one. If the location of the new 
piece is under the old head -- if the worm's direction is down, the y coordinate 
of the new piece should be by one bigger than the y coordinate of the head (when 
we draw, we will have to get accustometd to a coordinate system where the y axe 
is reverse).</P>
<P>When the worm moves, a new piece is added to the list, and the first piece is 
deleted from the beginning of the list. In this way, you don't need to update 
the coordinates of each single piece. Implement the growth so that the first 
piece is deleted if the <CODE>grow</CODE> method has just been called.</P>
<P>Attention! The worm has to grow constantly if its length is less than 3.</P>
<PRE class="sh_java">        Worm worm = new Worm(5, 5, Direction.RIGHT);
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());

        worm.grow();
        System.out.println(worm.getPieces());
        worm.move();
        System.out.println(worm.getPieces());

        worm.setDirection(Direction.LEFT);
        System.out.println(worm.runsIntoItself());
        worm.move();
        System.out.println(worm.runsIntoItself());
</PRE>
<PRE>[(5,5)]
[(5,5), (6,5)]
[(5,5), (6,5), (7,5)]
[(6,5), (7,5), (8,5)]
[(6,5), (7,5), (8,5)]
[(6,5), (7,5), (8,5), (9,5)]
false
true
</PRE>
<H4>Worm Game, Part 1</H4>
<P>Let's modify the class <CODE>WormGame</CODE> which is contained in 
<CODE>wormgame.game</CODE>, and encapsulates the functionality of the game. The 
class WormGame inherits the class <CODE>Timer</CODE>, which provides the time 
functionality to update the game. In order to work, the class <CODE>Timer</CODE> 
requires a class which implements the interface <CODE>ActionListener</CODE>, and 
we have implemented it in <CODE>WormGame</CODE>.</P>
<P>Modify the functionality of WormGame's constructor so that the game's 
<CODE>Worm</CODE> is created in the constructor. Create the worm so that the 
position of the worm depends on the parameters received in the constructor of 
the class WormGame. The worm's x coordinate has to be <CODE>width / 2</CODE>, 
the y coordinate <CODE>height / 2 </CODE>, and the direction 
<CODE>Direction.DOWN</CODE>.</P>
<P>Also create an apple inside the constructor. The apple coordinates have to be 
random, but the apple x coordinate has to be contained between <CODE>[0, 
width[</CODE>, and the y coordinate between <CODE>[0, height[</CODE>.</P>
<P>Also add the following methods to the WormGame:</P>
<UL>
  <LI><CODE>public Worm getWorm()</CODE> returns the WormGame worm.</LI>
  <LI><CODE>public void setWorm(Worm worm)</CODE> sets on the game the method 
  parameter worm. If the method <CODE>getWorm</CODE> is called after the worm 
  has been set up, it has to return a reference to the <EM>same</EM> worm.</LI>
  <LI><CODE>public Apple getApple</CODE> returns the apple of the WormGame.</LI>
  <LI><CODE>public void setApple(Apple apple)</CODE> sets the method parameter 
  apple on the worm game. If the method <CODE>getApple</CODE> is called after 
  the apple has been set up, it has to return a reference to the <EM>same</EM> 
  apple.</LI></UL>
<H4>Worm Game, Part 2</H4>
<P>Modify the functionality of the method <CODE>actionPerformed</CODE> so that 
it would implement the following tasks in the given order.</P>
<OL>
  <LI>Move the worm</LI>
  <LI>If the worm runs into the apple, it eats the apple and calls the grow 
  method. A new apple is randomly created.</LI>
  <LI>If the worm runs into itself, the variable <CODE>continue</CODE> is 
  assigned the value <CODE>false</CODE></LI>
  <LI>Call <CODE>update</CODE>, which is a method of the variable 
  <CODE>updatable</CODE> which implements the interface 
  <CODE>Updatable</CODE>.</LI>
  <LI>Call the <CODE>setDelay</CODE> method which is inherited from the Timer 
  class. The game velocity should grow with respect to the worm length. The call 
  <CODE>setDelay(1000 / <EM>worm</EM>.getLength());</CODE> will work for it: in 
  the call we expect that you have defined the object variable 
  <CODE>worm</CODE>.</LI></OL>
<P>Let's start next to build our user interface components.</P>
<H4>Keyboard listener</H4>
<P>Implement the class <CODE>KeyboardListener</CODE> in 
<CODE>wormgame.gui</CODE>. The class has the constructor <CODE>public 
KeyboardListener(Worm worm)</CODE>, and it implements the interface 
<CODE>KeyListener</CODE>. Replace the method <CODE>keyPressed</CODE> so that the 
worm is assigned direction up when the up arrow key. Respectively, the worm is 
assigned the directions down, left, or right, when the user presses the down, 
left, or right arrow key.</P>
<H4>DrawingBoard</H4>
<P>Create the class <CODE>DrawingBoard</CODE> in <CODE>wormgame.gui</CODE>. The 
<CODE>DrawingBoard</CODE> inherits the class <CODE>JPanel</CODE>, and its 
constructor receives an instance of the class <CODE>WormGame</CODE> and the int 
variable <CODE>pieceLength</CODE> as parameters. The variable 
<CODE>pieceLength</CODE> tells the dimension of the pieces; length and height of 
the pieces are equal.</P>
<P>Replace the <CODE>paintComponent</CODE> method which was inherited from the 
class <CODE>JPanel</CODE> so that the method draws the worm and the apple. Use 
the Graphics object's <CODE>fill3DRect</CODE> method to draw the worm. The worm 
colour has to be black (<CODE>Color.BLACK</CODE>). The apple has to be drawn 
with the Graphics object's <CODE>fillOval</CODE> method, and its colour has to 
be red.</P>
<P>Also implement the interface <CODE>Updatable</CODE> in 
<CODE>DrawingBoard</CODE>. The method <CODE>update</CODE> of Updatable has to 
call the <CODE>repaint</CODE> method of the class JPanel.</P>
<H4>User Interface</H4>
<P>Modify the class <CODE>UserInterface</CODE> to contain DrawingBoard. In the 
method <CODE>createComponents</CODE>, you have to create an instance of 
DrawingBoard and add it into the Container object. Create an instance of 
<CODE>KeyboardListener</CODE> at the end of <CODE>createComponents</CODE>, and 
add it to the Frame object.</P>
<P>Also add the method <CODE>public Updatable getUpdatable()</CODE> to the class 
<CODE>UserInterface</CODE>, returning the drawing board which was created in 
<CODE>createComponents</CODE>.</P>
<P>You can start the user interface from the <CODE>Main</CODE> class in the 
following way. Before the game starts, we wait that the user interface is 
created. When the user interface is created, it gets connected to the worm game 
and the game gets started.</P>
<PRE class="sh_java">        WormGame game = new WormGame(20, 20);

        UserInterface ui = new UserInterface(game, 20);
        SwingUtilities.invokeLater(ui);

        while (ui.getUpdatable() == null) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                System.out.println("The drawing board hasn't been created yet.");
            }
        }

        game.setUpdatable(ui.getUpdatable());
        game.start();
</PRE></DIV></DIV>
<H2>Course Feedback</H2>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Course Feedback</H3>
<P>We have received a lot of valuable feedback through TMC. Therefore, as your 
last task in the course we would like to have feedback on the course in general. 
Give feedback by filling out the comment section which appears when you have 
submitted the exercise. If comment section doesn't pop up, please write your 
feedback in the <CODE>Main</CODE>-class of the downloaded exercise and submit it 
again.</P>
<P>In order to receive the points of this exercise submit the exercise to our 
server. </P></DIV></DIV></DIV></DIV></DIV><!-- /inner -->   </DIV><!-- /node-327 --> 
        </DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper -->     
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- /content-content -->             
                                                  </DIV><!-- /content-inner-inner --> 
                            </DIV><!-- /content-inner -->                        
   </DIV><!-- /content-region-inner -->                         </DIV><!-- /content-region --> 
                        
<DIV class="content-bottom row nested " id="content-bottom">
<DIV class="content-bottom-inner inner clearfix" id="content-bottom-inner">
<DIV class="block block-block odd first last grid16-16" id="block-block-1">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="content clearfix">
<DIV id="header-top-block">
<P class="rtecenter">Ohjaus: <A href="http://mooc.fi/content/irc-ohjeet">IRCnet 
#mooc.fi </A>&nbsp;&nbsp; |  Tiedotus: <A href="http://twitter.com/mooc1"><IMG 
height="50" style="vertical-align: middle;" src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/twitter_newbird_blue.png"> 
Twitter </A><A href="http://www.facebook.com/Moocfi"><IMG height="30" style="padding: 10px; vertical-align: middle;" 
src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/f_logo-1.png"> 
Facebook</A>  |  Virheraportit: <A href="http://sourceforge.net/p/mooc-issues/tickets/"><IMG 
height="30" style="padding: 10px; vertical-align: middle;" src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/sf-footer-logo.png"> 
SourceForge</A></P>
<P class="rtecenter"><A href="http://www.cs.helsinki.fi/"><IMG width="400" 
style="vertical-align: middle;" alt="Helsingin yliopiston tietojenkäsittelytieteen laitos" 
src="Regular%20Expression,%20Iteration,%20Enum%20and%20Recap_files/CS-logo-MOOC.jpg">&nbsp; 
</A></P></DIV>
<SCRIPT>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-47575342-3', 'auto');
  ga('send', 'pageview');
 
</SCRIPT>
        </DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper -->     
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --></DIV><!-- /content-bottom-inner --> 
</DIV><!-- /content-bottom -->                       </DIV><!-- /content-group-inner --> 
                    </DIV><!-- /content-group -->                                
       </DIV><!-- /main-content-inner -->                 </DIV><!-- /main-content --> 
                              </DIV><!-- /main-group-inner -->             
</DIV><!-- /main-group -->           </DIV><!-- /main-inner -->         </DIV><!-- /main --> 
      </DIV><!-- /main-wrapper -->       <!-- postscript-bottom row: width = grid_width --> 
            <!-- footer row: width = grid_width -->             <!-- footer-message row: width = grid_width --> 
      
<DIV class="footer-message-wrapper full-width" id="footer-message-wrapper">
<DIV class="footer-message row grid16-16" id="footer-message">
<DIV class="footer-message-inner inner clearfix" id="footer-message-inner">
<DIV class="footer-message-text block" id="footer-message-text">
<DIV class="footer-message-text-inner inner clearfix" id="footer-message-text-inner"><BR></DIV><!-- /footer-message-text-inner --> 
</DIV><!-- /footer-message-text -->                    </DIV><!-- /footer-message-inner --> 
        </DIV><!-- /footer-message -->       </DIV><!-- /footer-message-wrapper --> 
    <!-- /page-inner -->   <!-- /page -->   </BODY></HTML>
