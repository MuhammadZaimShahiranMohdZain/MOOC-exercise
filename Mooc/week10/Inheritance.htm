<!DOCTYPE HTML>
<!-- saved from url=(0074)http://mooc.cs.helsinki.fi/programming-part2/material/week-10 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><HTML 
lang="en" lang="en" xml:lang="en" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><META content="IE=11.0000" 
http-equiv="X-UA-Compatible">
 
<META http-equiv="Content-Type" content="text/html; charset=utf-8">   
<TITLE>MOOC | MOOC - Massiivinen avoin verkkokurssi</TITLE>    <LINK href="/sites/mooc.cs.helsinki.fi/files/acquia_marina_favicon.png" 
rel="shortcut icon" type="image/x-icon">   <LINK href="Inheritance_files/5c1587b6907a85bc361bd4b70014b0e3.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/node.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/defaults.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/system.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/system-menus.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/user.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/content-module.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/ckeditor.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/ctools.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/date.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/panels.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/views.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/aeb58e3ce47f9171327ad9fd87a26c8e.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/flexible.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/style.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/typography.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/superfish.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/superfish-navbar.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/superfish-vertical.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/fusion-acquia-marina-style.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/custom.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/common.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/exercises.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/menu.css" 
rel="stylesheet" type="text/css" media="all"> <LINK href="Inheritance_files/sh_style.css" 
rel="stylesheet" type="text/css" media="all">   <LINK href="Inheritance_files/grid16-fluid.css" 
rel="stylesheet" type="text/css" media="all">   <!--[if IE 8]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie8-fixes.css?8" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie8-fixes.css?8" />
  <![endif]--> 
  <!--[if IE 7]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie7-fixes.css?8" />
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie7-fixes.css?8" />
  <![endif]--> 
  <!--[if lte IE 6]>
  <link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/fusion/fusion_core/css/ie6-fixes.css?8"/>
<link type="text/css" rel="stylesheet" media="all" href="/sites/all/themes/acquia_marina/css/ie6-fixes.css?8"/>
  <![endif]--> 
    
<SCRIPT src="Inheritance_files/jquery.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/drupal.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/panels.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/jquery.bgiframe.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/hoverIntent.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/supposition.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/supersubs.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/superfish.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/script.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/jquery.corner.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/acquia-marina-script.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/util-functions.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/clear-default-text.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/sh_java.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/sh_main.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/sh_ruby.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/sh_scala.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT type="text/javascript">
<!--//--><![CDATA[//><!--
jQuery.extend(Drupal.settings, { "basePath": "/" });
//--><!]]>
</SCRIPT>
 
<META name="GENERATOR" content="MSHTML 11.00.9600.18163"></HEAD>
<BODY class="not-front not-logged-in page-node node-type-weekly-tasks no-sidebars full-node panels layout-main sidebars-both-first font-family-lucida font-size-13 grid-type-fluid grid-width-16 fluid-100" 
id="pid-programming-part2-material-week-10">   
<DIV class="page" id="page">
<DIV class="page-inner" id="page-inner">
<DIV id="skip"><A href="http://mooc.cs.helsinki.fi/programming-part2/material/week-10?noredirect=1#main-content-area">Skip 
to Main Content Area</A>       </DIV><!-- header-top row: width = grid_width --> 
            <!-- header-group row: width = grid_width -->       
<DIV class="header-group-wrapper full-width" id="header-group-wrapper">
<DIV class="header-group row grid16-16" id="header-group">
<DIV class="header-group-inner inner clearfix" id="header-group-inner">
<DIV class="primary-menu block" id="primary-menu">
<DIV class="primary-menu-inner inner clearfix" id="primary-menu-inner">
<UL class="menu sf-menu">
  <LI class="expanded first"><A title="" 
  href="http://mooc.cs.helsinki.fi/home">Kurssit ››</A>
  <UL class="menu">
    <LI class="leaf first"><A title="" 
    href="http://mooc.fi/algoritmit">Algoritmien MOOC</A></LI>
    <LI class="leaf"><A title="" href="http://mooc.cs.helsinki.fi/2014-ohjelmointi">Olio-ohjelmointi 
    Javalla</A></LI>
    <LI class="leaf"><A title="" 
    href="http://mooc.aalto.fi/ohjelmointi/">Ohjelmointia Scalalla</A></LI>
    <LI class="leaf"><A title="" 
    href="http://mooc.fi/programming-part1">Object-Oriented Programming with 
    Java, part I</A></LI>
    <LI class="leaf"><A title="" 
    href="http://mooc.fi/programming-part2">Object-Oriented Programming with 
    Java, part II</A></LI>
    <LI class="leaf last"><A title="" 
    href="http://mooc.cs.helsinki.fi/wepa">Web-palvelinohjelmointi</A></LI></UL></LI>
  <LI class="collapsed"><A title="Mikä on MOOC?" href="http://mooc.cs.helsinki.fi/content/mik%C3%A4-mooc">Mikä 
  on MOOC? ››</A></LI>
  <LI class="leaf last"><A title="" href="http://mooc.cs.helsinki.fi/content/j%C3%A4rjest%C3%A4v%C3%A4st%C3%A4-tahosta">Järjestävästä 
  tahosta ››</A></LI></UL></DIV><!-- /primary-menu-inner --> </DIV><!-- /primary-menu --> 
          </DIV><!-- /header-group-inner -->         </DIV><!-- /header-group --> 
      </DIV><!-- /header-group-wrapper -->       <!-- preface-top row: width = grid_width --> 
        <!--            <div id="preface-top-wrapper" class="preface-top-wrapper full-width">
        <div id="preface-top" class="preface-top row grid16-16">
          <div id="preface-top-inner" class="preface-top-inner inner clearfix"> 
--> 
          </DIV><!-- /preface-top-inner -->         </DIV><!-- /preface-top -->  
     <!-- /preface-top-wrapper -->           <!-- main row: width = grid_width --> 
    
<DIV class="main-wrapper full-width" id="main-wrapper">
<DIV class="main row grid16-16" id="main">
<DIV class="main-inner inner clearfix" id="main-inner"><!-- main group: width = grid_width - sidebar_first_width --> 
          
<DIV class="main-group row nested grid16-16" id="main-group">
<DIV class="main-group-inner inner clearfix" id="main-group-inner">
<DIV class="main-content row nested" id="main-content">
<DIV class="main-content-inner inner clearfix" id="main-content-inner"><!-- content group: width = grid_width - (sidebar_first_width + sidebar_last_width) --> 
                    
<DIV class="content-group row nested " id="content-group" style="width: 100%;">
<DIV class="content-group-inner inner clearfix" id="content-group-inner">
<DIV class="content-region row nested" id="content-region">
<DIV class="content-region-inner inner clearfix" id="content-region-inner"><A 
name="main-content-area" id="main-content-area"></A>                             
                            
<DIV class="content-inner block" id="content-inner">
<DIV class="content-inner-inner inner clearfix" id="content-inner-inner">
<DIV class="content-content" id="content-content">
<DIV class="panel-flexible panels-flexible-13 clear-block">
<DIV class="panel-flexible-inside panels-flexible-13-inside">
<DIV class="panels-flexible-row panels-flexible-row-13-7 panels-flexible-row-first clear-block ">
<DIV class="inside panels-flexible-row-inside panels-flexible-row-13-7-inside panels-flexible-row-inside-first clear-block">
<DIV class="panels-flexible-region panels-flexible-region-13-js_ panels-flexible-region-first panels-flexible-region-last ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js_-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<DIV class="panel-pane pane-custom pane-2 ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<H1 class="title"><A 
href="http://mooc.cs.helsinki.fi/programming-part2">Object-Oriented Programming 
with Java, part II ››</A></H1></DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block -->
<DIV class="panel-region-separator"></DIV>
<DIV class="panel-pane pane-custom pane-3 ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content"><LINK href="Inheritance_files/menu(1).css" 
rel="stylesheet" type="text/css" media="screen"> <LINK href="Inheritance_files/common-new.css" 
rel="stylesheet" type="text/css" media="screen, print"> <LINK href="Inheritance_files/sh_style(1).css" 
rel="stylesheet" type="text/css" media="screen, print">        </DIV></DIV><!-- /inner-inner -->
	   </DIV><!-- /inner-wrapper -->     
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV></DIV></DIV>
<DIV class="panels-flexible-row panels-flexible-row-13-4 clear-block js">
<DIV class="inside panels-flexible-row-inside panels-flexible-row-13-4-inside clear-block">
<DIV class="panels-flexible-region panels-flexible-region-13-js_en_ panels-flexible-region-first ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js_en_-inside panels-flexible-region-inside-first"></DIV></DIV>
<DIV class="panels-flexible-region panels-flexible-region-13-js ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js-inside">
<DIV class="panel-pane pane-node ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="node odd full-node node-type-page" id="node-222">
<DIV class="inner">
<H2 class="title"><A title="" 
href="http://mooc.cs.helsinki.fi/content/js-en"></A></H2>
<DIV class="content clearfix">
<SCRIPT src="Inheritance_files/bootstrap.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/jquery-1.7.1.min.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/exercises-eng-new.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/common-mooc-eng.js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/sh_main.min(1).js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/sh_java.min(1).js" type="text/javascript"></SCRIPT>
 
<SCRIPT src="Inheritance_files/jquery.easing.js" type="text/javascript"></SCRIPT>
 
<DIV class="menu" id="toc" data-first-exercise-index="1" 
data-first-chapter-index="1"><SPAN id="materiaali_toc"></SPAN>           <!--div id="tehtavat_toc" ></div--> 
          <SPAN id="tehtavat_toc2"></SPAN>         </DIV></DIV></DIV><!-- /inner --> 
  </DIV><!-- /node-222 -->         </DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV>
<DIV class="panels-flexible-region panels-flexible-region-13-copyright panels-flexible-region-last float-right">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-copyright-inside panels-flexible-region-inside-last">
<DIV class="panel-pane pane-custom pane-1 box ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<P><A href="http://creativecommons.org/licenses/by-nc-sa/2.0/" 
rel="license"><IMG style="border-width: 0px; float: right;" alt="Creative Commons License" 
src="Inheritance_files/88x31.png"></A><SMALL>This material is licensed under the 
Creative Commons BY-NC-SA license, which means that you can use it and 
distribute it freely so long as you do not erase the names of the original 
authors. If you do changes in the material and want to distribute this altered 
version of the material, you have to license it with a similar free license. The 
use of the material for commercial use is prohibited without a separate 
agreement.</SMALL></P></DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block -->
<DIV class="panel-region-separator"></DIV>
<DIV class="panel-pane pane-content-field pane-field-author course-menu ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="field field-type-text field-field-author">
<DIV class="field-items">
<DIV class="field-item odd">                    Authors: Arto Vihavainen, Matti 
Luukkainen        </DIV></DIV></DIV></DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block -->
<DIV class="panel-region-separator"></DIV>
<DIV class="panel-pane pane-content-field pane-field-translators course-menu ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="field field-type-text field-field-translators">
<DIV class="field-items">
<DIV class="field-item odd">                    Translators: Simone Romeo, Kenny 
Heinonen        </DIV></DIV></DIV></DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV></DIV></DIV>
<DIV class="panels-flexible-row panels-flexible-row-13-8 panels-flexible-row-last clear-block js en">
<DIV class="inside panels-flexible-row-inside panels-flexible-row-13-8-inside panels-flexible-row-inside-last clear-block">
<DIV class="panels-flexible-region panels-flexible-region-13-js_en panels-flexible-region-first panels-flexible-region-last ">
<DIV class="inside panels-flexible-region-inside panels-flexible-region-13-js_en-inside panels-flexible-region-inside-first panels-flexible-region-inside-last">
<DIV class="panel-pane pane-node-content box-mooc ">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="pane-content content">
<DIV class="node even full-node node-type-weekly_tasks" id="node-323">
<DIV class="inner">
<DIV class="content clearfix">
<DIV class="viikkoraja-mooc" id="Week 10" data-first-exercise-index="134" 
data-first-chapter-index="48" tekija="Arto Vihavainen, Matti Luukkainen" 
data-first-week-index-mooc="10" data-first-exercise-index-mooc="27" 
data-first-chapter-index-mooc="49" data-first-week-index="10" deadline="unlocks when 85% of week 9 done ">
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>The Finnish Ringing Centre</H3>
<P>In the sixth week of Introduction to Programming, we created an observation 
database for bird watching. Now we continue in the same vein, and this time, we 
create a program for the ringing centre to track of the places where the rung 
birds were observed.</P><BIG></BIG>
<P><STRONG>ATTENTION:</STRONG> You may run into a strange error message in this 
exercise, such as <CODE>NoSuchMethodError: Bird.equals(BBird;)Z</CODE>; if this 
happens, <STRONG>clean and build</STRONG>, i.e. press the brush and hammer icon 
in NetBeans.</P>
<H4>Bird equals and toString</H4>
<P>The Finnish Ringing Centre stores the information about the birds who were 
watched in a specific year in <CODE>Bird</CODE> objects:</P>
<PRE class="sh_java">public class Bird {

    private String name;
    private String latinName;
    private int ringingYear;

    public Bird(String name, String latinName, int ringingYear) {
        this.name = name;
        this.latinName = latinName;
        this.ringingYear = ringingYear;
    }

    @Override
    public String toString() {
        return this.latinName + "(" + this.ringingYear + ")";
    }
}

</PRE>
<P>The idea is implementing the funcionality for the ringing centre to track of 
the places where rung birds were observed and how many times they were. However, 
observation places and times are not stored in Bird objects, but in a separate 
HashMap, whose keys are Bird objects. As we remember from Week 2, in such cases 
we have to implement the methods <CODE>equals(Object other)</CODE> and 
<CODE>hashCode()</CODE> in the class <CODE>Bird</CODE>.</P>
<P>Some birds have more than one English name (for instance, the Rose Starling 
is also known as Rose-Coloured Starling or Rose-Coloured Pastor); however, the 
Latin name is always unique. Create the methods <CODE>equals</CODE> and 
<CODE>hashCode-</CODE> in the class <CODE>Bird</CODE>; two Bird objects have to 
be understood as the same bird if their Latin name and observation year are the 
same.</P>
<P>Example:</P>
<PRE>    Bird bird1 = new Bird("Rose Starling", "Sturnus roseus", 2012);
    Bird bird2 = new Bird("Rose-Coloured Starling", "Sturnus roseus", 2012);
    Bird bird3 = new Bird("Hooded Crow", "Corvus corone cornix", 2012);
    Bird bird4 = new Bird("Rose-Coloured Pastor", "Sturnus roseus", 2000);

    System.out.println( bird1.equals(bird2));   // same Latin name and same observation year: they are the same bird
    System.out.println( bird1.equals(bird3));   // different Latin name: they are not the same bird
    System.out.println( bird1.equals(bird4));   // different observation year: not the same bird
    System.out.println( bird1.hashCode()==bird2.hashCode() );
</PRE>
<P>Prints:</P>
<PRE>true
false
false
true
</PRE>
<H4>Ringing Centre</H4>
<P>The Ringing Centre has two methods: <CODE>public void observe(Bird bird, 
String place)</CODE>, which records the observation and its place among the bird 
information; and <CODE>public void observations(Bird bird)</CODE>, which prints 
all the observations of the parameter bird following the example below. The 
observation printing order is not important, as far as the tests are 
concerned.</P>
<P>The Ringing Centre stores the observation places in a <CODE>Map&lt;Bird, 
List&lt;String&gt;&gt;</CODE> object variable. If you need, you can use the 
exercise from Section 16 as example.</P>
<P>An example of how the Ringing Centre works:</P>
<PRE class="sh_java">    RingingCentre kumpulaCentre = new RingingCentre();

    kumpulaCentre.observe( new Bird("Rose Starling", "Sturnus roseus", 2012), "Arabia" );
    kumpulaCentre.observe( new Bird("Rose-Coloured Starling", "Sturnus roseus", 2012), "Vallila" );
    kumpulaCentre.observe( new Bird("European Herring Gull", "Larus argentatus", 2008), "Kumpulanmäki" );
    kumpulaCentre.observe( new Bird("Rose Starling", "Sturnus roseus", 2008), "Mannerheimintie" );

    kumpulaCentre.observations( new Bird("Rose-Coloured Starling", "Sturnus roseus", 2012 ) );
    System.out.println("--");
    kumpulaCentre.observations( new Bird("European Herring Gull", "Larus argentatus", 2008 ) );
    System.out.println("--");
    kumpulaCentre.observations( new Bird("European Herring Gull", "Larus argentatus", 1980 ) );
</PRE>
<P>Prints:</P>
<PRE>Sturnus roseus (2012) observations: 2
Arabia
Vallila
--
Larus argentatus (2008) observations: 1
Kumpulanmäki
--
Larus argentatus (1980) observations: 0
</PRE></DIV></DIV>
<H2>Object Polymorphism</H2>
<P>Precedently, we have run into situations where variables had various 
different types, in addition to their own. For instance, in the section <A href="http://mooc.cs.helsinki.fi/programming-part2/material/week-10?noredirect=1#45">45</A>, 
we noticed that <EM>all</EM> objects are <CODE>Object</CODE>-type. If an object 
is a particular type, we can also represent it as <CODE>Object</CODE>-type. For 
instance, <CODE><A href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" 
target="_blank">String</A></CODE> is also <CODE>Object</CODE>-type, and all 
<CODE>String</CODE> variables can be defined using <CODE>Object</CODE>.</P>
<PRE class="sh_java">    String string = "string";
    Object string = "another string";
</PRE>
<P>It is possible to assign a String to an <CODE>Object</CODE>-type 
reference.</P>
<PRE class="sh_java">    String string = "characterString";
    Object string = string;
</PRE>
<P>The opposite way does not work. Because <CODE>Object</CODE>-type variables 
are not Strings, an Object variable cannot be assigned to a String variable.</P>
<PRE class="sh_java">    Object string = "another string";
    String string = string; // DOESN'T WORK!
</PRE>
<P>What is the real problem?</P>
<P>Variables have got their own type, and in addition to it they also have got 
the type of their parent classes and interfaces. The class <CODE>String</CODE> 
derives from the <CODE>Object</CODE> class, and therefore <CODE>String</CODE> 
objects are also <CODE>Object</CODE>-type. The class <CODE>Object</CODE> does 
not derive from the class <CODE>String</CODE>, and therefore <CODE>Object</CODE> 
variables are not automatically <CODE>String</CODE>-type. Let's dig deeper into 
the <CODE><A href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</A></CODE> 
class API documentation, expecially the upper part of the HTML page.</P>
<P><IMG src="Inheritance_files/string-api.png"></P>
<P>The String class API documentation starts with the common heading; this is 
followed by the class package (<CODE>java.lang</CODE>). After the package you 
find the class name (<CODE>Class String</CODE>), and this is followed by the 
<EM>inheritance hierarchy</EM>.</P>
<PRE><A href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html">java.lang.Object</A>
  <IMG src="Inheritance_files/perinta.gif"><STRONG>java.lang.String</STRONG>
</PRE>
<P>The inheritance hierarchy lists the classes from which a class derives. The 
inherited classes are listed in hierarchical order, where the class we are 
analizing is the last one. As far as our String class inheritance hierarchy is 
concerned, we notice that the <CODE>String</CODE> class derives from the class 
<CODE>Object</CODE>. <EM>In Java, each class can derive from one class, 
tops</EM>; however, they can inherit features of more than one, undirectly.</P>
<P>You can think inheritance hierarchy as if it was a list of types, which the 
object has to implement.</P>
<P>The fact that all objects are <CODE>Object</CODE>-type helps programming. If 
we only need the features defined in the <CODE>Object</CODE> class in our 
method, we can use <CODE>Object</CODE> as method parameter. Because all objects 
are also Object-type, a method can be given <EM>whatever</EM> object as 
parameter. Let's create the method <CODE>printManyTimes</CODE>, which receives 
an <CODE>Object</CODE> variable as parameter, and the number of times this must 
be printed.</P>
<PRE class="sh_java">public class Printer {
    ...
    public void printManyTimes(Object object, int times) {
        for (int i = 0; i &lt; times; i++) {
            System.out.println(object.toString());
        }
    }
    ...
}
</PRE>
<P>You can give whaterver object parameter to the method 
<CODE>printManyTimes</CODE>. Within the method <CODE>printManyTimes</CODE>, the 
object has only the method which are defined in the <CODE>Object</CODE> class at 
its disposal, because the method is <EM>presented</EM> as 
<CODE>Object</CODE>-type inside the mehod.</P>
<PRE class="sh_java">    Printer printer = new Printer();

    String string = " o ";
    List&lt;String&gt; words = new ArrayList&lt;String&gt;();
    words.add("polymorphism");
    words.add("inheritance");
    words.add("encapsulation");
    words.add("abstraction");

    printer.printManyTimes(string, 2);
    printer.printManyTimes(words, 3);
</PRE>
<PRE> o
 o
[polymorphism, inheritance, encapsulation, abstraction]
[polymorphism, inheritance, encapsulation, abstraction]
[polymorphism, inheritance, encapsulation, abstraction]
</PRE>
<P>Let's continue with our <CODE>String</CODE> class API inspection. In the 
description, the inheritance hierarchy is followed by a list of the interfaces 
which the class implements.</P>
<PRE><STRONG>All Implemented Interfaces:</STRONG>
  <A title="interface in java.io" href="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html">Serializable</A>, <A title="interface in java.lang" href="http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html">CharSequence</A>, <A title="interface in java.lang" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</A>&lt;<A title="class in java.lang" href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</A>&gt;
</PRE>
<P>The <CODE>String</CODE> class implements the interfaces 
<CODE>Serializable</CODE>, <CODE>CharSequence</CODE>, and 
<CODE>Comparable&lt;String&gt;</CODE>. An interface is a type, too. According to 
the description of the String API, we should be able to set the following 
interfaces as the type of a String object.</P>
<PRE class="sh_java">    Serializable serializableString = "string";
    CharSequence charSequenceString = "string";
    Comparable&lt;String&gt; comparableString = "string";
</PRE>
<P>Because we can define the parameter type of a method, we can define methods 
which would accept an object which implements <EM>a specific interface</EM>. 
When we define an interface as method parameter, the parameter can be whatever 
object which implements such interface, the method does not care about the 
object actual type.</P>
<P>Let's implement our <CODE>Printer</CODE> class, and create a method to print 
the characters of the objects which implement the interface 
<CODE>CharSequence</CODE>. The <CODE>CharSequence</CODE> interface also provides 
methods such as <CODE>int length()</CODE>, which returns the String's length, 
and <CODE>char charAt(int index)</CODE>, which returns the character at a 
specific index.</P>
<PRE class="sh_java">public class Printer {
    ...
    public void printManyTimes(Object object, int times) {
        for (int i = 0; i &lt; times; i++) {
            System.out.println(object.toString());
        }
    }

    public void printCharacters(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }
    ...
}
</PRE>
<P>Whatever object which implements the <CODE>CharSequence</CODE> interface can 
be assigned to the method <CODE>printCharacters</CODE>. For instance, you can 
give a <CODE>String</CODE> or a <CODE>StringBuilder</CODE> which is usually more 
efficient when it comes to string building. The method 
<CODE>printCharacters</CODE> prints each character of the object in its own 
line.</P>
<PRE class="sh_java">    Printer printer = new Printer();

    String string = "works";

    printer.printCharacters(string);
</PRE>
<PRE>w
o
r
k
s
</PRE>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Groups</H3>
<P>In this exercise, we make organisms and groups of organisms which move around 
each other. The position of the organisms is reported by using a 
<EM>bidimensional coordinate system</EM>. Each position is defined by two 
numbers, the <CODE>x</CODE> and <CODE>y</CODE> coordinates. The <CODE>x</CODE> 
coordinate tells us how far from the "point zero" the position is horizontally, 
whereas the <CODE>y</CODE> coordinate tells u how far the position is 
vertically. If you have got doubts of what a coordinate system is, you can read 
more information in <A 
href="http://en.wikipedia.org/wiki/Coordinate_system">Wikipedia</A>, for 
instance.</P>
<P>Together with the exercise, you find the interface <CODE>Movable</CODE>, 
which represents things that can be moved from one place to another. The 
interface contains the method <CODE>void move(int dx, int dy)</CODE>. The 
parameter <CODE>dx</CODE> tells us how much the object moves on the x axis and 
<CODE>dy</CODE> tells us about the movement on the y axis.</P>
<P>Implement the classes <CODE>Organism</CODE> and <CODE>Group</CODE>, which are 
both movable. Implement all the functionality inside the package 
<CODE>movable</CODE>.</P>
<H4>Implementing Organism</H4>
<P>Create the class <CODE>Organism</CODE> in the package <CODE>movable</CODE>; 
let Organism implement the interface <CODE>Movable</CODE>. Organisms have to 
know their own position (x and y coordinates). The API of <CODE>Organism</CODE> 
has to be the following:</P>
<UL>
  <LI>the constructor <STRONG>public Organism(int x, int y)</STRONG><BR>; it 
  receives the x and y initial coordinates of the object</LI>
  <LI><STRONG>public String toString()</STRONG><BR>; it creates and returns a 
  string which represents the object. The form should be the following <CODE>"x: 
  3; y: 6"</CODE>. Note that the coordinates are separated by a semicolon 
  (<CODE>;</CODE>)</LI>
  <LI><STRONG>public void move(int dx, int dy)</STRONG><BR>; it moves the object 
  as much as it is specified by the arguments. The variable <CODE>dx</CODE> 
  contains the x coordinate of the movement, whereas <CODE>dy</CODE> contains 
  the y coordinate of the movement. For instance, if the value of the variable 
  <CODE>dx</CODE> is 5, the object variable <CODE>x</CODE> has to be increased 
  by five</LI></UL>
<P>Try our the functionality of <CODE>Organism</CODE> using the following 
code.</P>
<PRE class="sh_java">     Organism organism = new Organism(20, 30);
     System.out.println(organism);
     organism.move(-10, 5);
     System.out.println(organism);
     organism.move(50, 20);
     System.out.println(organism);
</PRE>
<PRE>x: 20; y: 30
x: 10; y: 35
x: 60; y: 55
</PRE>
<H4>Implementing Group</H4>
<P>Create the class <CODE>Group</CODE> in the package <CODE>movable</CODE>; 
Group implements the interface <CODE>Movable</CODE>. The Group is made of 
various different objects which implement the interface <CODE>Movable</CODE>, 
and they have to be stored into a list construction, for instance.</P>
<P>The class <CODE>Group</CODE> should have the following API.</P>
<UL>
  <LI><STRONG>public String toString()</STRONG><BR>; it returns a string which 
  describes the position of the group organisms, each organism is printed in its 
  own line.</LI>
  <LI><STRONG>public void addToGroup(Movable movable)</STRONG><BR>; it adds a 
  new objects which implements the interface <CODE>Movable</CODE> to the 
  group.</LI>
  <LI><STRONG>public void move(int dx, int dy)</STRONG><BR>; it moves a group as 
  much as it is defined by the arguments. Note that you will have to move each 
  group organism.</LI></UL>
<P>Try out your program functionality with the following code.</P>
<PRE class="sh_java">    Group group = new Group();
    group.addToGroup(new Organism(73, 56));
    group.addToGroup(new Organism(57, 66));
    group.addToGroup(new Organism(46, 52));
    group.addToGroup(new Organism(19, 107));
    System.out.println(group);
</PRE>
<PRE>x: 73; y: 56
x: 57; y: 66
x: 46; y: 52
x: 19; y: 107
</PRE></DIV></DIV>
<H2>Inheritance of Class Features</H2>
<P>Classes are for the programmer a way to clarify problematic concepts. With 
each class we create, we add new functionality to the programming language. The 
functionality is needed to solve the problems we meet, and the solutions are 
born from the interaction among the objects we create. In object programming, an 
object is an independent unity which can change through its methods. Objects are 
used together with each other; each object has its own area of responsibility. 
For instance, our user interface classes have been making use of 
<CODE>Scanner</CODE> objects, so far.</P>
<P>Each Java's class descends from the class <CODE>Object</CODE>, which means 
that each class we create has all methods which are defined in 
<CODE>Object</CODE>. If we want to change the functionality of the methods 
defined in <CODE>Object</CODE>, we have to <CODE>Override</CODE> them and define 
a new functionality in the created class.</P>
<P>In addition to be possible to inherit the <CODE>Object</CODE> class, it is 
also possible to inherit other classes. If we check Java's <CODE><A href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html" 
target="_blank">ArrayList</A></CODE> class API we notice that 
<CODE>ArrayList</CODE> inherits the class <CODE>AbstractList</CODE>. The class 
<CODE>AbstractList</CODE> inherits the class <CODE>AbstractCollection</CODE>, 
which descended from the class <CODE>Object</CODE>.</P>
<PRE><A href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">java.lang.Object</A>
  <IMG src="Inheritance_files/perinta.gif"><A href="http://docs.oracle.com/javase/6/docs/api/java/util/AbstractCollection.html" target="_blank">java.util.AbstractCollection</A>&lt;E&gt;
      <IMG src="Inheritance_files/perinta.gif"><A href="http://docs.oracle.com/javase/6/docs/api/java/AbstractList.html" target="_blank">java.util.AbstractList</A>&lt;E&gt;
          <IMG src="Inheritance_files/perinta.gif"><STRONG>java.util.ArrayList&lt;E&gt;</STRONG>
</PRE>
<P>Each class can inherit one class, directly, Indirectly, a class can still 
inherit all the feauters its parent class. The class <CODE>ArrayList</CODE> 
inherits directly the class <CODE>AbstractList</CODE>, and indirectly the 
classes <CODE>AbstractCollection</CODE> and <CODE>Object</CODE>. In fact, the 
class <CODE>ArrayList</CODE> has the methods <EM>and</EM> interfaces of 
<CODE>AbstractList</CODE>, <CODE>AbstractCollection</CODE> and 
<CODE>Object</CODE> at its disposal.</P>
<P>The class features are inherited using the keyword <CODE>extends</CODE>. The 
class which inherits is called <EM>subclass</EM>; the class which is inherited 
is called <EM>superclass</EM>. Let's get aquainted with a carmaker system, which 
handles car components. The basic component of component handling is the class 
<CODE>Component</CODE> which defines the identification number, the producer, 
and the description.</P>
<PRE class="sh_java">public class Component {

    private String id;
    private String producer;
    private String description;

    public Component(String id, String producer, String description) {
        this.id = id;
        this.producer = producer;
        this.description = description;
    }

    public String getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getProducer() {
        return producer;
    }
}
</PRE>
<P>One car component is its motor. As for all the other components, the motor 
has also got a producer, an identification number, and a description. In 
addition, a motor has also got a type: for instance, combustion engine, electric 
motor, or hybrid. Let's create the class <CODE>Motor</CODE> which inherits 
<CODE>Component</CODE>: a motor is a particular case of component.</P>
<PRE class="sh_java">public class Motor extends Component {

    private String motorType;

    public Motor(String motorType, String id, String producer, String description) {
        super(id, producer, description);
        this.motorType = motorType;
    }

    public String getMotorType() {
        return motorType;
    }
}
</PRE>
<P>The class definition <CODE>public class Motor extends Component</CODE> tells 
us that the class <CODE>Motor</CODE> inherits the functionality of 
<CODE>Component</CODE>. In the class <CODE>Motor</CODE>, we define the object 
variable <CODE>motorType</CODE>.</P>
<P>The Motor class constructor is interesting. In the first line of the 
constructor we notice the keyword <CODE>super</CODE>, which is used to call the 
superclass constructor. The call <CODE>super(id,producer,description)</CODE> 
class the constructor <CODE>public Component(String id, String producer, String 
description)</CODE> which is defined in the class <CODE>Component</CODE>; in 
this way the superclass object variables are assigned a value. After doing this, 
we assign a value to the object variable <CODE>motorType</CODE>.</P>
<P>When the class <CODE>Motor</CODE> inherits the class <CODE>Component</CODE>, 
in receives all the methods provides by <CODE>Component</CODE>. It is possible 
to create an instance of the class <CODE>Motor</CODE> as it is for any other 
class.</P>
<PRE class="sh_java">        Motor motor = new Motor("combustion engine", "hz", "volkswagen", "VW GOLF 1L 86-91");
        System.out.println(motor.getMotorType());
        System.out.println(motor.getProducer());
</PRE>
<PRE>combustion engine
volkswagen
</PRE>
<P>As you notice, the class <CODE>Motor</CODE> has the methods defined in 
<CODE>Component</CODE> at its disposal.</P>
<H3>Private, Protected and Public</H3>
<P>If a method or a variable have got the <CODE>private</CODE> field 
accessibility, it can not be seen by its subclasses, and its subclasses do not 
have any straight way to access it. In the previous example Motor can't access 
directly the attributes defined in its superclass Component (id, producer, 
description). The subclass see naturally everything which has been defined 
<CODE>public</CODE> in its super class. If we want to define superclass 
variables or methods whose accessibility should be restricted to only its 
subclasses, we can use the <CODE>protected</CODE> field accessability.</P>
<H3>Superclass</H3>
<P>The superclass constructor is defined by the <CODE>super</CODE> keyword. In 
fact, the call <CODE>super</CODE> is similar to the <CODE>this</CODE> 
constructor call. The call is given the values of the type required by the super 
class constructor parameter.</P>
<P>When we call the constructor, the variables defined in the super class are 
initialized. In fact, with constructor call happens the same thing as in normal 
constructor calls. Unless the superclass has a constructor without parameter, in 
the subclass constructor call there must always be a call for its superclass 
constructor.</P>
<P>Attention! The <CODE>super</CODE> call must always be in the first line!</P>
<H3>Calling the Superclass Methods</H3>
<P>The method defined in the superclass can always be called using the 
<CODE>super</CODE> prefix, in the same way we call the methods defined in this 
class through the <CODE>this</CODE> prefix. For instance, we can make use of a 
method which overrives the superclass <CODE>toString</CODE> method in the 
following way:</P>
<PRE class="sh_java">    @Override
    public String toString() {
        return super.toString() + "\n  And my personal message again!";
    }
</PRE>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Person and their Heirs</H3>
<H4 class="req">Person</H4>
<P>Create the package <CODE>people</CODE> and the class <CODE>Person</CODE> in 
it; Person works in relation to the following main program:</P>
<PRE class="sh_java">    public static void main(String[] args) {
        Person pekka = new Person("Pekka Mikkola", "Korsontie Street 1 03100 Vantaa");
        Person esko = new Person("Esko Ukkonen", "Mannerheimintie Street 15 00100 Helsinki");
        System.out.println(pekka);
        System.out.println(esko);
    }
</PRE>
<P>Printing</P>
<PRE>Pekka Mikkola
  Korsontie Street 1 03100 Vantaa
Esko Ukkonen
  Mannerheimintie Street 15 00100 Helsinki
</PRE>
<H4 class="req">Student</H4>
<P>Create the class <CODE>Student</CODE> which <I>inherits</I> the class 
<CODE>Person</CODE>.   </P>
<P>Students have 0 credits, at the beginning. As long as a student studies, 
their credits grow. Create the class, in relation to the following main 
program:</P>
<PRE class="sh_java">    public static void main(String[] args) {
        Student olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
        System.out.println(olli);
        System.out.println("credits " + olli.credits());
        olli.study();
        System.out.println("credits "+ olli.credits());
    }
</PRE>
<P>Prints:</P>
<PRE>Olli
  Ida Albergintie Street 1 00400 Helsinki
credits 0
credits 1
</PRE>
<H4 class="req">toString for Studets</H4>
<P>The <CODE>Student</CODE> in the previous exercise inherits their toString 
method from the class <CODE>Person</CODE>. Inherited methods can also be 
overwritten, that is to say replaced with another version. Create now an own 
version of the toString method for <CODE>Student</CODE>; the method has to work 
as shown below:</P>
<PRE class="sh_java">    public static void main(String[] args) {
        Student olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
        System.out.println( olli );
        olli.study();
        System.out.println( olli );
    }
</PRE>
<P>Prints:</P>
<PRE>Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 0
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 1
</PRE>
<H4 class="req">Teacher</H4>
<P>Create the class <CODE>Teacher</CODE> in the same package. Teacher inherits 
<CODE>Person</CODE>, but they also have a salary, which together with the 
teacher information in String form.</P>
<P>Check whether the following main program generates the prinout below</P>
<PRE class="sh_java">    public static void main(String[] args) {
        Teacher pekka = new Teacher("Pekka Mikkola", "Korsontie Street 1 03100 Vantaa", 1200);
        Teacher esko = new Teacher("Esko Ukkonen", "Mannerheimintie 15 Street 00100 Helsinki", 5400);
        System.out.println( pekka );
        System.out.println( esko );

        Student olli = new Student("Olli", "Ida Albergintie 1 Street 00400 Helsinki");
        for ( int i=0; i &lt; 25; i++ ) {
            olli.study();
        }
        System.out.println( olli );
    }
</PRE>
<P>Printing</P>
<PRE>Pekka Mikkola
  Korsontie Street 1 03100 Vantaa
  salary 1200 euros/month
Esko Ukkonen
  Mannerheimintie Street 15 00100 Helsinki
  salary 5400 euros/month
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 25
</PRE>
<H4 class="req">Everyone in a List</H4>
<P>Implement the method <CODE>public static void 
printDepartment(List&lt;Person&gt; people)</CODE> in the <CODE>Main</CODE> 
class, default package. The method prints all the people in the parameter list. 
When the <CODE>main</CODE> method is called, printDepartment should work in the 
following way.</P>
<PRE class="sh_java">    public static void printDepartment(List&lt;Person&gt; people) {
       // we print all the people in the department
    }

    public static void main(String[] args) {
        List&lt;Person&gt; people = new ArrayList&lt;Person&gt;();
        people.add( new Teacher("Pekka Mikkola", "Korsontie Street 1 03100 Vantaa", 1200) );
        people.add( new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki") );

        printDepartment(people);
    }
</PRE>
<PRE>Pekka Mikkola
  Korsontie Street 1 03100 Vantaa
  salary 1200 euros/month
Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 0
</PRE></DIV></DIV>
<H3>The Object Type defines the Called Method: Polymorphism</H3><!-- WTF -->     
<P>The method which can be called is defined through the variable type. For 
instance, if a <CODE>Student</CODE> object reference is saved into a 
<CODE>Person</CODE> variable, the object can use only the methods defined in the 
<CODE>Person</CODE> class:</P>
<PRE class="sh_java">   Person olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
   olli.credits();        // NOT WORKING!
   olli.study();              // NOT WORKING!
   String.out.println( olli );   // olli.toString() IT WORKS!
</PRE>
<P>If the object has many different types, it has available the methods defined 
by <EM>all</EM> types. For instance, a <CODE>Student</CODE> object has available 
the methods defined both in the class <CODE>Person</CODE> and in 
<CODE>Object</CODE>.</P>
<P>In the previous exercise, we were in the class <CODE>Student</CODE> and we 
replaced the <CODE>toString</CODE> method inherited from <CODE>Person</CODE> 
with a new version of it. Suppose we are using an object throw a type which is 
not its real, what version of the object method would we call, then? For 
instance, below there are two students whose references are saved into a Person 
and an Object variables. We call the <CODE>toString</CODE> method of both. What 
version of the method is executed: the one defined in Object, in Person, or in 
Student?</P>
<PRE class="sh_java">   Person olli = new Student("Olli", "Ida Albergintie Street 1 00400 Helsinki");
   String.out.println( olli );

   Object liisa = new Student("Liisa", "Väinö Auerin Street 20 00500 Helsinki");
   String.out.println( liisa );
</PRE>
<P>Printing:</P>
<PRE>Olli
  Ida Albergintie Street 1 00400 Helsinki
  credits 0
Liisa
  Väinö Auerin Street 20 00500 Helsinki
  credits 0
</PRE>
<P>As you see, the execution method is chosen based on its real type, that is 
the type of the variable which saved the reference!</P>
<P>More generally: <B>The execution method is always chosen based on the object 
real type, regardless of the variable type which is used. Objects are diverse, 
which means they can be used through different variable types. The execution 
method does always depend of the object actual type.</B> This diversity is 
called polymorphysm.</P>
<H3>Another Example: Points</H3>
<P>A point laying in a bidimensional coordinate system can be represented with 
the help of the following class:</P>
<PRE class="sh_java">public class Point {

    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int manhattanDistanceFromOrigin(){
        return Math.abs(x)+Math.abs(y);
    }

    protected String location(){
        return x + ", " + y;
    }

    @Override
    public String toString() {
        return "("+this.location()+") distance "+this.manhattanDistanceFromOrigin();
    }
}
</PRE>
<P>The <CODE>location</CODE> method is not supposed to be used outside its 
class, and its accessability field is protected, which means only subclasses can 
access it. For instance, if we use a <A href="http://wiki.gamegardens.com/Path_Finding_Tutorial">path 
fiding algorithm</A>, the <A href="http://en.wiktionary.org/wiki/Manhattan_distance">Manhattan 
distance</A> is the distance of two points moving on a strictly horizontal 
and/or vertical path, along the coordinate system lines.</P>
<P>A coloured point is similar to a point, except that it contains a string 
which tells us its colour. The class can be created by inheriting Point:</P>
<PRE class="sh_java">public class ColouredPoint extends Point {

    private String colour;

    public ColouredPoint(int x, int y, String colour) {
        super(x, y);
        this.colour = colour;
    }

    @Override
    public String toString() {
        return super.toString()+" colour: "+colour;
    }
}
</PRE>
<P>The class defines an object variable which saves the colour. The coordinates 
are saved in the superclass. The string representation must be similar to the 
one of the point, but it also has to show the colour. The overwritten 
<CODE>toString</CODE> method, calls the superclass toString method, and it adds 
the point colour to it.</P>
<P>In the following example, we create a list which contains various different 
points, either normal or coloured. Thanks to polymorphysm, we call the actual 
toString method of all objects, even though the list knows them as if they were 
all <CODE>Point</CODE>-type:</P>
<PRE class="sh_java">public class Main {
    public static void main(String[] args) {
        List&lt;Point&gt; points = new ArrayList&lt;Point&gt;();
        points.add(new Point(4, 8));
        points.add(new ColouredPoint(1, 1, "green"));
        points.add(new ColouredPoint(2, 5, "blue"));
        points.add(new Point(0, 0));

        for (Point point : points) {
            System.out.println(point);
        }
    }
}
</PRE>
<P>Printing:</P>
<PRE>(4, 8) distance 12
(1, 1) distance 2 colour: green
(2, 5) distance 7 colour: blue
(0, 0) distance 0
</PRE>
<P>We also want a 3D point in our program. Because that is not a coloured point, 
it shall inherit Point:</P>
<PRE class="sh_java">public class 3DPoint extends Point {

    private int z;

    public 3DPoint(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String location() {
        return super.location() + ", " + z;    // printing as "x, y, z"
    }

    @Override
    public int manhattanDistanceFromOrigin() {
        // first, we ask the superclass for the distance of x+y
        // and then we add the value of z to it
        return super.manhattanDistanceFromOrigin() + Math.abs(z);
    }

    @Override
    public String toString() {
        return "(" + this.location() + ") distance " + this.manhattanDistanceFromOrigin();
    }
}
</PRE>
<P>A 3D point defines an object variable corresponding to the third coordinate, 
and it overrides the methods <CODE>location</CODE>, 
<CODE>manhattanDistanceFromOrigin</CODE> and <CODE>toString</CODE> so that they 
would take into account the tridimensionality. We can now extend the previous 
example and add 3D points to our list:</P>
<PRE class="sh_java">public class Main {

    public static void main(String[] args) {
        List&lt;Point&gt; points = new ArrayList&lt;Point&gt;();
        points.add(new Point(4, 8));
        points.add(new ColouredPoint(1, 1, "green"));
        points.add(new Point(2, 5, "blue"));
        points.add(new 3DPoint(5, 2, 8));
        points.add(new Point(0, 0));

        for (Point point : points) {
            System.out.println(point);
        }
    }
}
</PRE>
<P>The output meets our expectations</P>
<PRE>(4, 8) distance 12
(1, 1) distance 2 colour: green
(2, 5) distance 7 colour: blue
(5, 2, 8) distance 15
(0, 0) distance 0
</PRE>
<P>We notice that the tridimensional point <CODE>toString</CODE> method is 
exactly the same as the point's toString. Could we leave the toString method 
untouched? Of course! A tridimensional point can be reduced to the 
following:</P>
<PRE class="sh_java">public class 3DPoint extends Point {

    private int z;

    public 3DPoint(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String distance() {
        return super.distance()+", "+z;
    }

    @Override
    public int manhattanDistanceFromOrigin() {
        return super.manhattanDistanceFromOrigin()+Math.abs(z);
    }
}
</PRE>
<P>What does exactly happen when we call a tridimensional point's toString 
method? The execution proceeds in the following way:</P>
<OL>
  <LI>we look for a toString method in the class 3DPoint; this is not found and 
  we move to its parent class</LI>
  <LI>we look for a toString method in the superclass Point; the method is found 
  and we execute its code</LI></OL>
<UL>
  <LI>the code to execute is <CODE>return "("+this.location()+") location 
  "+this.manhattanDistanceFromOrigin();</CODE></LI>
  <LI>first, we execute the method location</LI>
  <LI>we look for a location method in the class 3DPoint; the method is found 
  and we executes its code </LI>
  <LI>the location method calculates its result by calling the superclass method 
  location</LI>
  <LI>next, we look for the definition of the method manhattanDistanceFromOrigin 
  in the class Point3D; the method is found and we execute its code</LI>
  <LI>once again, the method calculates its result by calling its homonym in the 
  superclass</LI></UL>
<P>The operating sequence produced by the method call has many steps. The idea 
is clear, anyway: when we want to execute a method, we first look for its 
definition in the object real type, and if it is not found, we move to the super 
class. If the method is not found in the parent class either, we move to the 
parent parent class, and so on...</P>
<H3>When Do We Have to Use Inheritance?</H3>
<P>Inheritance is a tool to build and qualify object hierarchy; a subclass is 
always a special instance of the superclass. If the class we want to create is a 
special instance of an already existent class, we can create it by inheriting 
the class which already exists. For instance in our auto components example, 
motor <EM>is</EM> a component, but the motor has additional functionality which 
not all the classe          s have.</P>
<P>Through inheritance, a subclass receives the superclass functionality. If a 
subclass does not need or use the inherited functionality, inheritance is not 
motivated. The inherited classes inherit the upperclass methods and interfaces, 
and therefore we can use a subclass for any purpose the superclass was used. It 
is good to stick to low inheritance hierarchy, because the more complex the 
inheritance hierarchy is, the more complex maintainance and further development 
will be. In general, if the hierarchy is higher than two or three, the program 
structure is usually to improve.</P>
<P>It is good to think about inheritance use. For instance, if <CODE>Car</CODE> 
inherited classes like <CODE>Component</CODE> or <CODE>Motor</CODE>, that would 
be wrong. A car <EM>contains</EM> a motor and components, but a car is not a 
motor or a component. More generally, we can think that if an object owns or is 
composed of the other objects, inheritance is wrong.</P>
<P>Devoloping hierachy, you have to make sure the Single Responsibility 
Principle applies. There must be only one reason to change a  class. If you 
notice that the hierarchy increases a class responsibilities, that class must be 
divided into various different classes.</P>
<H4>An Example of Inheritance Misuse</H4>
<P>Let's think about the <CODE>Customer</CODE> class, in relation to post 
service. The class contains the customer personal information, and 
<CODE>Order</CODE>, which inherits the customer personal information and 
contains the information of the object to order. The class <CODE>Order</CODE> 
has also got the method <CODE>mailingAddress</CODE>, which tells the mailing 
address of the order.</P>
<PRE class="sh_java">public class Customer {

    private String name;
    private String address;

    public Customer(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public String getName() {
        return name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
</PRE>
<PRE class="sh_java">public class Order extends Customer {

    private String product;
    private String amount;

    public Order(String product, String amount, String name, String address) {
        super(name, address);
        this.product = product;
        this.amount = amount;
    }

    public String getProduct() {
        return product;
    }

    public String getAmount() {
        return amount;
    }

    public String mailingAddress() {
        return this.getName() + "\n" + this.getAddress();
    }
}
</PRE>
<P>The inheritance above is used erroneously. When a class inherits another, the 
subclass has to be a special instance of the superclass; order is not a special 
instance of customer. The misuse becomes apparent by breaking the single 
responsibility principle: the class <CODE>Order</CODE> is responsible for both 
the customer and the order information maintenance.</P>
<P>The problem with the previous solution becomes apparent when we think of what 
would happen if a customer changes their own address.</P>
<P>With a change of address, we would have to change <EM>each</EM> Order object 
of the customer, which is a hint about a bad situation. A better solution would 
be encapsulating <CODE>Customer</CODE> as an object variable of 
<CODE>Order</CODE>. If we think more specifically about the order semantics this 
becomes clear. <EM>An order has a customer</EM>. Let's change the class 
<CODE>Order</CODE> so that it contains a reference to <CODE>Customer</CODE>.</P>
<PRE class="sh_java">public class Order {

    private Customer customer;
    private String product;
    private String amount;

    public Tilaus(Customer customer, String product, String amount) {
        this.customer = customer;
        this.product = product;
        this.amount = amount;
    }

    public String getProduct() {
        return product;
    }

    public String getAmount() {
        return amount;
    }

    public String mailingAddress() {
        return this.customer.getName() + "\n" + this.customer.getAddress();
    }
}
</PRE>
<P>The <CODE>Order</CODE> class above is better now. The method 
<CODE>mailingAddress</CODE> uses a <EM>Customer</EM> reference to retrieve the 
mailing address, instead of inheriting the class <CODE>Customer</CODE>. This 
makes easier both the maintanance and the concrete functionality of our 
program.</P>
<P>Now, when we modify a customer, we only need to change their information; we 
don't have to do anything about the orders.</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Container</H3>
<P>Together with the exercise, you find the class <CODE>Container</CODE>, with 
the following constructor and methods:</P>
<UL>
  <LI><B>public Container(double capacity)</B><BR>     It creates an empty 
  container, whose capacity is given as argument;     an improper capacity 
  (&lt;=0) creates a useless container,     whose capacity is 0.</LI>
  <LI><B>public double getVolume()</B><BR>     It returns the volume of product 
  in the container.</LI>
  <LI><B>public double getOriginalCapacity()</B><BR>     It returns the original 
  capacity of the container, that is to say what the constructor was originally 
  given.</LI>
  <LI><B>public double getCurrentCapacity()</B><BR>     It returns the actual 
  capacity of the container.</LI>
  <LI><B>public void addToTheContainer(double amount)</B><BR>     It adds the 
  specified amount of things to the container. If the amount is negative, 
  nothing changes;     if a part of that amount fits but not the whole of it, 
  the container is filled up     and the left over is thrown away.</LI>
  <LI><B>public double takeFromTheContainer(double amount)</B><BR>    We take 
  the specified amount form the container, the method returns what we 
  <B>receive</B>.    If the specified amount is negative, nothing happens and 
  zero is returned.    If we ask for more than what there is in the container, 
  the method returns all the contents.</LI>
  <LI><B>public String toString()</B><BR>    It returns the state of an object 
  in String form like <TT>volume = 64.5, free space 123.5</TT></LI></UL>
<P>In this exercise, we create various different containers out of our 
<CODE>Container</CODE> class. Attention! Create all the classes in the package 
<CODE>containers</CODE>.</P>
<H4 class="req">Product Container, Phase 1</H4>
<P>The class <CODE>Container</CODE> has control on the operations regarding the 
amount of a product. Now, we also want that products have their name and 
handling equipment. <I><B>Program ProductContainer, a subclass of 
Container!</B></I> Let's first implement a single object variable for the name 
of the contained product, a constructor and a getter for the name:</P>
<UL>
  <LI><B>public ProductContainer(String productName, double capacity)</B><BR>    
   It creates an empty product container. The product name and the container 
  capacity are given as parameters.</LI>
  <LI><B>public String getName()</B><BR>     It returns the product 
name.</LI></UL>
<P><I>Remember in what way the constructor can make use of its upper class 
constructor in its first line!</I></P>
<P>Example:</P>
<PRE class="sh_java">        ProductContainer juice = new ProductContainer("Juice", 1000.0);
        juice.addToTheContainer(1000.0);
        juice.takeFromTheContainer(11.3);
        System.out.println(juice.getName()); // Juice
        System.out.println(juice);           // volume = 988.7, free space 11.3
</PRE>
<PRE>Juice
volume = 988.7, free space 11.3
</PRE>
<H4 class="req">Product Container, Phase 2</H4>
<P>As you see from the example above, the <CODE>toString()</CODE> method 
inherited by ProductContainer does not know anything about the product name (of 
course!). <I>Something must be done for it!</I> Let's also add a setter for the 
product name, at the same time:</P>
<UL>
  <LI><B>public void setName(String newName)</B> sets a new name to the 
  product.</LI>
  <LI><B>public String toString()</B> returns the object state in String form, 
  like <TT>Juice: volume = 64.5, free space 123.5</TT></LI></UL>
<P>The new <CODE>toString()</CODE> method could be programmed using the getter 
inherited from the superclass, retrieving the values of inherited but hidden 
values field values. However, we have programmed the superclass in a way that it 
is already able to produce the container situation in String form: why should we 
bother to program this again? Make use of the inherited 
<CODE>toString</CODE>.</P>
<P><I>Remember that an overwritten method can still be called in its subclass, 
where we overwrite it!</I></P>
<P>Use demonstration:</P>
<PRE class="sh_java">        ProductContainer juice = new ProductContainer("Juice", 1000.0);
        juice.addToTheContainer(1000.0);
        juice.takeFromTheContainer(11.3);
        System.out.println(juice.getName()); // Juice
        juice.addToTheContainer(1.0);
        System.out.println(juice);           // Juice: volume = 989.7, space 10.299999999999955
</PRE>
<PRE>Juice
Juice: volume = 989.7, free space 10.299999999999955
</PRE>
<H4>Container History</H4>
<P>Sometimes, it can be interesting to know in what way the container situation 
has changed: is the container often rather empty or full, is the fluctuation 
considerable or not, and so on. Let's provide our <CODE>ProductContainer</CODE> 
class with the ability to record the container history.</P>
<P>Let's start by designing a useful tool.</P>
<P>We could directly implement an <CODE>ArrayList&lt;Double&gt;</CODE> object to 
track our container history in the class <I>ProductConteiner</I>; however, now 
we create a <I>specific tool</I> for this purpose. The tool has to encapsulate 
an <CODE>ArrayList&lt;Double&gt;</CODE> object.</P>
<P><CODE>ContainerHistory</CODE> public constructor and methods:</P>
<UL>
  <LI><B>public ContainerHistory()</B> creates an empty 
  <CODE>ContainerHistory</CODE> object.</LI>
  <LI><B>public void add(double situation)</B> adds the parameter situation to 
  the end of the container history. </LI>
  <LI><B>public void reset()</B> it deletes the container history records.</LI>
  <LI><B>public String toString()</B> returns the container history in the form 
  of a String. <I>The String form given by the ArrayList class is fine and 
  doesn't have to be modified.</I> </LI></UL>
<H4 class="req">ContainerHistory.java, Phase 2</H4>
<P>Implement analysis methods for your <CODE>ContainerHistory</CODE> class:</P>
<UL>
  <LI><B>public double maxValue()</B> reutrns the greatest value in the 
  container history. If the history is empty, the method returns 0.</LI>
  <LI><B>public double minValue()</B> reutrns the smallest value in the 
  container history. If the history is empty, the method returns 0.</LI>
  <LI><B>public double average()</B> reutrns the average of the values in the 
  container history. If the history is empty, the method returns 0.</LI></UL>
<H4>ContainerHistory.java, Phase 3</H4>
<P>Implement analysis methods for your <CODE>ContainerHistory</CODE> class:</P>
<UL>
  <LI><B>public double greatestFluctuation()</B> returns the absolute value of 
  the single greatest fluctuation in the container history (attention: a 
  fluctuation of -5 is greater than 4). If the history is empty or it contains 
  one value, the method returns zero. Absolute value is the distance of a number 
  from zero. For instance the absolute value of -5.5 is 5.5, and the absolute 
  value of 3.2 is 3.2.</LI>
  <LI><B>public double variance()</B> returns the sample variance of the 
  container history values. If the history is empty or it contains only one 
  value, the method returns zero.</LI></UL>
<P>You find guidelines to calculate the variance in <A href="http://en.wikipedia.org/wiki/Variance#Population_variance_and_sample_variance">Wikipedia</A>, 
in the population and sample variance section. For instance, the average of the 
numbers 3, 2, 7, and 2 is 3.5, and their sample variance is therefore ((3 - 
3.5)² + (2 - 3.5)² + (7 - 3.5)² + (2 - 3.5)²)/(4 - 1) ˜ 5,666667.)</P>
<H4 class="req">Product Container Recorder, Phase 1</H4>
<P>Implement the class <CODE>ProductContainerRecorder</CODE> which inherits 
<CODE>ProductContainer</CODE>. In addition to the old methods, the new version 
provides services for the container history. The hisotry is handled with a  
<CODE>ContainerHistory</CODE> object. </P>
<P>The public constructor and methods:</P>
<UL>
  <LI><B>public ProductContainerRecorder(String productName, double capacity, 
  double initialVolume)</B>     creates a product container. The product name, 
  capacity, and original volume are given as parameter.      <I>Record the 
  original volume both as the stored product original volume and as the first 
  value of the container history.</I> </LI>
  <LI><B>public String history()</B> returns the container history in the 
  following form:        <TT>[0.0, 119.2, 21.2]</TT>.  <I>Use the String 
  printout form as it is.</I> </LI></UL>
<P><B>Attention:</B> now we remember only the original volume. </P>
<P>Example: </P>
<PRE class="sh_java">// the well known way:
ProductContainerRecorder juice = new ProductContainerRecorder("Juice", 1000.0, 1000.0);
juice.takeFromTheContainer(11.3);
System.out.println(juice.getName()); // Juice
juice.addToTheContainer(1.0);
System.out.println(juice);           // Juice: volume = 989.7, free space 10.3
...
<B>// history() does not work properly, yet:</B>
System.out.println(juice.history()); // [1000.0]
   // in fact, we only retrieve the original value which was given to the constructor...
...
</PRE>
<P>Printing: </P>
<PRE>Juice
Juice: volume = 989.7, free space 10.299999999999955
[1000.0]
</PRE>
<H4 class="req">Product Container Recorder, Phase 2</H4>
<P><I>It's time to pick up history!</I> The first version of our history knew 
only the original value. Implement the following methods: </P>
<UL>
  <LI><B>public void addToTheContainer(double amount)</B>;    this works like 
  the method in <I>Container</I>, but the new situation is recorded in the 
  history. <B>Attention: </B> you have to record the product volume in the 
  container after the addition, not the amount which was added! </LI>
  <LI><B>public double takeFromTheContainer(double amount)</B>; it works like 
  the method in <CODE>Container</CODE>, but the new situation is recorded in the 
  history. <B>Attention: </B> you have to record the product volume in the 
  container after the operation, not the amount which was removed!</LI></UL>
<P>Use example: </P>
<PRE class="sh_java">// the well known way:
ProductContainerRecorder juice = new ProductContainerRecorder("Juice", 1000.0, 1000.0);
juice.takeFromTheContainer(11.3);
System.out.println(juice.getName()); // Juice
juice.addToTheContainer(1.0);
System.out.println(juice);           // Juice: volume = 989.7, free space 10.3
...
// but now we have our history record
System.out.println(juice.history()); // [1000.0, 988.7, 989.7]
...
</PRE>
<P>Printing: </P>
<PRE>Juice
Juice: volume = 989.7, free space 10.299999999999955
[1000.0, 988.7, 989.7]
</PRE>
<P></P>
<P><I>Remember how an overwritten method can be used inside the method that 
overwrites it!</I> </P>
<H4 class="req">Product Container Recorder, Phase 3</H4>
<P>Implement the following method: </P>
<UL>
  <LI><B>public void printAnalysis()</B>, which prints the history information 
  regarding the product, following the exercise below:</LI></UL>
<P>Use example: </P>
<PRE class="sh_java">ProductContainerRecorder juice = new ProductContainerRecorder("Juice", 1000.0, 1000.0);
juice.takeFromTheContainer(11.3);
juice.addToTheContainer(1.0);
//System.out.println(juice.history()); // [1000.0, 988.7, 989.7]

juice.printAnalysis();
</PRE>
<P>The method <I>printAnalysis</I> prints: </P>
<PRE>Product: Juice
History: [1000.0, 988.7, 989.7]
Greatest product amount: 1000.0
Smallest product amount: 988.7
Average: 992.8
Greatest change: 11.299999999999955
Variance: 39.129999999999676
</PRE>
<P></P>
<H4>Product Container Recorder, Phase 4</H4>
<P>Fill the analysis so that it prints the greatest fluctuation and the history 
variance. </P></DIV></DIV>
<H3>Inheritance, Interfaces, Both, or None?</H3>
<P>Inheritance does not exclude using interfaces, and viceversa. Interfaces are 
like an agreement on the class implementation, and they allow for the 
abstraction of the concrete implementation. Changing a class which implements an 
interface is quite easy.</P>
<P>As with interfaces, when we make use of inheritance, the subclasses are 
committed to provide all the superclass methods. Because of polymorphism, 
inheritance works as interfaces do. We can assign a subclass instance to a 
method which receives its superclass as parameter.</P>
<P>Below, we create a farm simulator, where we simulate the life in a farm. Note 
that the program does not make us of inheritance, and the interface use is 
scarce. With programs, we often create a first version which we improve later 
on. Typically, we don't already understand the scope of the problem when we 
implement the first version; planning interfaces and inheritance hierarchy may 
be difficult and it may slow down the work.</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Farm Simulator</H3>
<P>Dairy farms have got milking animals; they do not handle milk themselves, but 
milk trucks transport it to dairy factories which process it into a variety of 
milk products. Each dairy factory is specialised in one product type; for 
instance, a cheese factory produces cheese, a butter factory produces butter, 
and a milk factory produces milk. </P>
<P></P>
<P>Let's create a simulator which represents the milk course of life. Implement 
all the classes in the package <CODE>farmsimulator</CODE>. </P>
<P></P>
<H4>Bulk Tank</H4>
<P>Milk has to be stored in bulk tanks in good conditions. Bulk tanks are 
produced both with a standard capacity of 2000 litres, and with customer 
specific capacity. Create the class BulkTank, with the following constructors 
and methods. </P>
<UL>
  <LI><STRONG>public BulkTank()</STRONG></LI>
  <LI><STRONG>public BulkTank(double capacity)</STRONG></LI>
  <LI><STRONG>public double getCapacity()</STRONG></LI>
  <LI><STRONG>public double getVolume()</STRONG></LI>
  <LI><STRONG>public double howMuchFreeSpace()</STRONG></LI>
  <LI><STRONG>public void addToTank(double amount)</STRONG> adds to the tank 
  only as much milk as it fits; the additional milk will not be added, and you 
  don't have to worry about a situation where the milk spills over</LI>
  <LI><STRONG>public double getFromTank(double amount)</STRONG>      takes the 
  required amount from the tank, or as much as there is left     </LI></UL>
<P>Also, implement the <CODE>toString</CODE> method for your 
<CODE>BulkTank</CODE>. The <CODE>toString</CODE> method describes the tank 
situation by rounding down the litres using the <CODE>ceil()</CODE> method of 
class <CODE>Math</CODE>. </P>
<P>Test your bulk tank with the following program chunk:</P>
<PRE class="sh_java">BulkTank tank = new BulkTank();
tank.getFromTank(100);
tank.addToTank(25);
tank.getFromTank(5);
System.out.println(tank);

tank = new BulkTank(50);
tank.addToTank(100);
System.out.println(tank);
</PRE>
<P>The program print output should look like the following:</P>
<PRE>20.0/2000.0
50.0/50.0
</PRE>
<P>Note that when you call the <CODE>println()</CODE> method of the 
<CODE>out</CODE> object of class <CODE>System</CODE>, the method receives as 
paramater an <CODE>Object</CODE> variable; in such case, the print output is 
determined by the overwritten <CODE>toString()</CODE> method in 
<CODE>BulkTank</CODE>! We are in front of a case of polymorphism, because the 
method can work with different types. </P>
<H4>Cow</H4>
<P>If we want to produce milk, we also need cows. Cows have got names and 
udders. Udder capacity is a random value between 15 and 40; the class 
<CODE>Random</CODE> can be used to raffle off the numers, for instance, 
<CODE>int num = 15 + new Random().nextInt(26);</CODE>. The class 
<CODE>Cow</CODE> has the following functionality:</P>
<UL>
  <LI><STRONG>public Cow()</STRONG> creates a new cow with a random name</LI>
  <LI><STRONG>public Cow(String name)</STRONG> creates a new cow with its given 
  name</LI>
  <LI><STRONG>String getName()</STRONG> returns the cow's name</LI>
  <LI><STRONG>double getCapacity()</STRONG> returns the udder capacity</LI>
  <LI><STRONG>double getAmount()</STRONG> returns the amount on milk available 
  in the cow's udders</LI>
  <LI><STRONG>String toString()</STRONG> returns a String which describes the 
  cow (see the example below)</LI></UL>
<P><CODE>Cow</CODE> also implement the following interfaces: 
<CODE>Milkable</CODE>, which describes the cow's faculty for being milked, and 
<CODE>Alive</CODE>, which represents their faculty for being alive.</P>
<PRE class="sh_java">public interface Milkable {
    public double milk();
}

public interface Alive {
    public void liveHour();
}
</PRE>
<P>When a cow is milked, all their milk provision is taken to be processed. As 
long as a cow lives, their milk provision increases slowly. In Finland, milking 
cows produce 25-30 litres of milk every day, on the average. We simulate this by 
producing 0.7-2 litres every hour. </P>
<P>If a cow is not given a name, they are assigned a random one from the list 
below. </P>
<PRE class="sh_java">    private static final String[] NAMES = new String[]{
        "Anu", "Arpa", "Essi", "Heluna", "Hely",
        "Hento", "Hilke", "Hilsu", "Hymy", "Ihq", "Ilme", "Ilo",
        "Jaana", "Jami", "Jatta", "Laku", "Liekki",
        "Mainikki", "Mella", "Mimmi", "Naatti",
        "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
        "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
</PRE>
<P>Implement the class Cow, and test whether it works with the following program 
body.</P>
<PRE class="sh_java">Cow cow = new Cow();
System.out.println(cow);


Alive livingCow = cow;
livingCow.liveHour();
livingCow.liveHour();
livingCow.liveHour();
livingCow.liveHour();

System.out.println(cow);

Milkable milkingCow = cow;
milkingCow.milk();

System.out.println(cow);
System.out.println("");

cow = new Cow("Ammu");
System.out.println(cow);
cow.liveHour();
cow.liveHour();
System.out.println(cow);
cow.milk();
System.out.println(cow);
</PRE>
<P>The program print output can be like the following.</P>
<PRE>Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
</PRE>
<H4>MilkingRobot</H4>
<P>In modern dairy farms, milking robots handle the milking. The milking robot 
has to be connected to the bulk tank in order to milk an udder: </P>
<UL>
  <LI><STRONG>public MilkingRobot()</STRONG> creates a new milking robot</LI>
  <LI><STRONG>BulkTank getBulkTank()</STRONG> returns the connected bulk tank, 
  or a <CODE>null</CODE> reference, if the tank hasn't been installed</LI>
  <LI><STRONG>void setBulkTank(BulkTank tank)</STRONG> installs the parameter 
  bulk tank to the milking robot</LI>
  <LI><STRONG>void milk(Milkable milkable)</STRONG> milks the cow and fills the 
  connected bulk tank; the method returns an <CODE>IllegalStateException</CODE> 
  is no tank has been fixed </LI></UL>
<P>Implement the class MilkingRobot, and test it using the following program 
body. Make sure that the milking robot can milk all the objects which implement 
the interface Milkable!</P>
<PRE class="sh_java">        MilkingRobot milkingRobot = new MilkingRobot();
        Cow cow = new Cow();
        milkingRobot.milk(cow);
</PRE>
<PRE>Exception in thread "main" java.lang.IllegalStateException: The MilkingRobot hasn't been installed
        at farmsimulator.MilkingRobot.milk(MilkingRobot.java:17)
        at farmsimulator.Main.main(Main.java:9)
Java Result: 1
</PRE>
<PRE class="sh_java">MilkingRobot milkingRobot = new MilkingRobot();
Cow cow = new Cow();
System.out.println("");

BulkTank tank = new BulkTank();
milkingRobot.setBulkTank(tank);
System.out.println("Bulk tank: " + tank);

for(int i = 0; i &lt; 2; i++) {
    System.out.println(cow);
    System.out.println("Living..");
    for(int j = 0; j &lt; 5; j++) {
        cow.liveHour();
    }
    System.out.println(cow);

    System.out.println("Milking...");
    milkingRobot.milk(cow);
    System.out.println("Bulk tank: " + tank);
    System.out.println("");
}
</PRE>
<P>The print output of the program can look like the following:</P>
<PRE>Bulk tank: 0.0/2000.0
Mella 0.0/23.0
Living..
Mella 6.2/23.0
Milking...
Bulk tank: 6.2/2000.0

Mella 0.0/23.0
Living..
Mella 7.8/23.0
Milking...
Bulk tank: 14.0/2000.0
</PRE>
<H4>Barn</H4>
<P>Cows are kept (and in this case milked) in barns. The original barns have 
room for one milking robot. Note that when milking robots are installed, they 
are connected to a specific barn's bulk tank. If a barn does not have a milking 
robot, it can't be used to handle the cow, either. Implement the class 
<CODE>Barn</CODE> with the following constructor and methods: </P>
<UL>
  <LI><STRONG>public Barn(BulkTank tank)</STRONG></LI>
  <LI><STRONG>public BulkTank getBulkTank()</STRONG> returns the barn's bulk 
  tank</LI>
  <LI><STRONG>public void installMilkingRobot(MilkingRobot 
  milkingRobot)</STRONG> installs a milking robot and connects it to the barn 
  bulk tank</LI>
  <LI><STRONG>public void takeCareOf(Cow cow)</STRONG> milks the parameter cow 
  with the help of the milking robot, the method throws an 
  <CODE>IllegalStateException</CODE> if the milking robot hasn't been 
  installed</LI>
  <LI><STRONG>public void takeCareOf(Collection&lt;Cow&gt; cows)</STRONG> milks 
  the parameter cows with the help of the milking robot, the method throws an 
  <CODE>IllegalStateException</CODE> if the milking robot hasn't been 
  installed</LI>
  <LI><STRONG>public String toString()</STRONG> returns the state of the bulk 
  tank contained by the barn</LI></UL>
<P><CODE>Collection</CODE> is Java's own interface, and it represents 
collections' behaviour. For instance, the classes <CODE>ArrayList</CODE> and 
<CODE>LinkedList</CODE> implement the interface <CODE>Collection</CODE>. All 
instances of classes which implement <CODE>Collection</CODE> can be iterated 
with a for-each construction.</P>
<P>Test your class <CODE>Barn</CODE> with the help of the following program 
body. Do not pay to much attention to the class <CODE>LinkedList</CODE>; 
apparently, it works as <CODE>ArrayList</CODE>, but the implemantation in 
encapsulates is slightly different. More information about this in the data 
structures course! </P>
<PRE class="sh_java">Barn barn = new Barn(new BulkTank());
System.out.println("Barn: " + barn);

MilkingRobot robot = new MilkingRobot();
barn.installMilkingRobot(robot);

Cow ammu = new Cow();
ammu.liveHour();
ammu.liveHour();

barn.takeCareOf(ammu);
System.out.println("Barn: " + barn);

LinkedList&lt;Cow&gt; cowList = new LinkedList&lt;Cow&gt;();
cowList.add(ammu);
cowList.add(new Cow());

for(Cow cow: cowList) {
    cow.liveHour();
    cow.liveHour();
}

barn.takeCareOf(cowList);
System.out.println("Barn: " + barn);
</PRE>
<P>The print output should look like the following: </P>
<PRE>Barn: 0.0/2000.0
Barn: 2.8/2000.0
Barn: 9.6/2000.0
</PRE>
<H4>Farm</H4>
<P>Farms have got an owner, a barn and a herd of cows. Farm also implements our 
old interface <CODE>Alive</CODE>: calling the method <CODE>liveHour</CODE> makes 
all the cows of the farm live for an hour.   You also have to create method 
<CODE>manageCows</CODE> which calls Barn's method <CODE>takeCareOf</CODE> so 
that all cows are milked. Implement your class Farm, and make it work according 
to the following example. </P>
<PRE class="sh_java">Farm farm = new Farm("Esko", new Barn(new BulkTank()));
System.out.println(farm);

System.out.println(farm.getOwner() + " is a tough guy!");
</PRE>
<P>Expected print output: </P>
<PRE>Farm owner: Esko
Barn bulk tank: 0.0/2000.0
No cows.
Esko is a tough guy!
</PRE>
<PRE class="sh_java">Farm farm = new Farm("Esko", new Barn(new BulkTank()));
farm.addCow(new Cow());
farm.addCow(new Cow());
farm.addCow(new Cow());
System.out.println(farm);
</PRE>
<P>Expected print output: </P>
<PRE>Farm owner: Esko
Barn bulk tank: 0.0/2000.0
Animals:
        Naatti 0.0/19.0
        Hilke 0.0/30.0
        Sylkki 0.0/29.0
</PRE>
<PRE class="sh_java">Farm farm = new Farm("Esko", new Barn(new BulkTank()));

farm.addCow(new Cow());
farm.addCow(new Cow());
farm.addCow(new Cow());

farm.liveHour();
farm.liveHour();
System.out.println(farm);
</PRE>
<P>Expected print output: </P>
<PRE>Farm owner: Esko
Barn bulk tank: 0.0/2000.0
Animals:
        Heluna 2.0/17.0
        Rima 3.0/32.0
        Ilo 3.0/25.0
</PRE>
<PRE class="sh_java">Farm farm = new Farm("Esko", new Barn(new BulkTank()));
MilkingRobot robot = new MilkingRobot();
farm.installMilkingRobot(robot);

farm.addCow(new Cow());
farm.addCow(new Cow());
farm.addCow(new Cow());


farm.liveHour();
farm.liveHour();

farm.manageCows();

System.out.println(farm);
</PRE>
<P>Expected print output: </P>
<PRE>Farm owner: Esko
Barn bulk tank: 18.0/2000.0
Animals:
        Hilke 0.0/30.0
        Sylkki 0.0/35.0
        Hento 0.0/34.0
</PRE></DIV></DIV>
<H3>An Abstract Class</H3>
<P>Abstract classes combine interfaces and inheritance. They do not produce 
instances, but you can create instances of their subclasses. An abstract class 
can contain both normal and abstract methods, the first containing the method 
body, the second having only the method definition. The implementation of the 
abstract methods is left to the inheriting class. In general, we use abstract 
classes when the object they represent is not a clear, self-defined concept. In 
such cases, it is not possible to create instances of it.</P>
<P>Both when we define abstract classes and abstract methods, we use the keyword 
<CODE>abstract</CODE>. An abstract class is defined by the statement 
<CODE>public abstract class <EM>ClassName</EM></CODE>, whereas an abstract 
method is defined by <CODE>public abstract <EM>returnType</EM> 
<EM>methodName</EM></CODE>. Let's consider the following abstract class 
<CODE>Operation</CODE>, which provides a framework for operations, and their 
excecutions.</P>
<PRE class="sh_java">public abstract class Operation {

    private String name;

    public Operation(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    public abstract void execute(Scanner reader);
}
</PRE>
<P>The abstract class <CODE>Operation</CODE> works as a framework to excetute 
different operations. For instance, an addition can be implemented by inheriting 
the class <CODE>Operation</CODE> in the following way.</P>
<PRE class="sh_java">public class Addition extends Operation {

    public Addition() {
        super("Addition");
    }

    @Override
    public void execute(Scanner reader) {
        System.out.print("Give the first number: ");
        int first = Integer.parseInt(reader.nextLine());
        System.out.print("Give the second number: ");
        int second = Integer.parseInt(reader.nextLine());

        System.out.println("The sum is " + (first + second));
    }
}
</PRE>
<P>Because all classes which descend from <CODE>Operation</CODE> are also 
Operation-type, we can create a user interface based on 
<CODE>Operation</CODE>-type variables. The following class 
<CODE>UserInterface</CODE> contains a list of operations and a reader. The 
operations can be added dynamically in the user interface.</P>
<PRE class="sh_java">public class UserInterface {

    private Scanner reader;
    private List&lt;Operation&gt; operations;

    public UserInterface(Scanner reader) {
        this.reader = reader;
        this.operations = new ArrayList&lt;Operation&gt;();
    }

    public void addOperation(Operation operation) {
        this.operations.add(operation);
    }

    public void start() {
        while (true) {
            printOperations();
            System.out.println("Choice: ");

            String choice = this.reader.nextLine();
            if (choice.equals("0")) {
                break;
            }

            executeOperation(choice);
            System.out.println();
        }
    }

    private void printOperations() {
        System.out.println("\t0: Quit");
        for (int i = 0; i &lt; this.operations.size(); i++) {
            String operationName = this.operations.get(i).getName();
            System.out.println("\t" + (i + 1) + ": " + operationName);
        }
    }

    private void executeOperation(String choice) {
        int operation = Integer.parseInt(choice);

        Operation chosen = this.operations.get(operation - 1);
        chosen.execute(reader);
    }
}
</PRE>
<P>The user interface works in the following way:</P>
<PRE class="sh_java">        UserInterface ui = new UserInterface(new Scanner(System.in));
        ui.addOperation(new Addition());

        ui.start();
</PRE>
<PRE>Operations:
        0: Quit
        1: Addition
Choice: <FONT color="red">1</FONT>
Give the first number: <FONT color="red">8</FONT>
Give the second number: <FONT color="red">12</FONT>
The sum is 20

Operations:
        0: Quit
        1: Addition
Choice: <FONT color="red">0</FONT>
</PRE>
<P>The difference between interfaces and abstract classes is that abstract 
classes provide the program with more structure. Because it is possible to 
define the functionality of abstract classes, we can use them to define the 
default implementation, for instance. The user interface above made use of a 
definition of the abstract class to store the operation name.</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Different Boxes</H3>
<P>Together with the exercise body, you find the classes <CODE>Thing</CODE> and 
<CODE>Box</CODE>. The class <CODE>Box</CODE> is abstract, and it is programmed 
so that adding things always implies calling the method <CODE>add</CODE>. The 
<CODE>add</CODE> method, resposible of adding one thing, is abstract, and any 
box which inherits the class <CODE>Box</CODE> has to implement the method 
<CODE>add</CODE>. Your task is modifying the class <CODE>Thing</CODE> and 
implementing various different boxes based on <CODE>Box</CODE>.</P>
<P>Add all new classes to the package <CODE>boxes</CODE>.</P>
<PRE class="sh_java">package boxes;

import java.util.Collection;

public abstract class Box {

    public abstract void add(Thing thing);

    public void add(Collection&lt;Thing&gt; things) {
        for (Thing thing : things) {
            add(thing);
        }
    }

    public abstract boolean isInTheBox(Thing thing);
}
</PRE>
<H4>Modifications to Thing</H4>
<P>Add an inspection to the constructor of <CODE>Thing</CODE>, to make sure that 
the thing's weight is never negative (weight 0 is accepted). If the weight is 
negative, the constructor has to throw an <CODE>IllegalArgumentException</CODE>. 
Also implement the methods <CODE>equals</CODE> and <CODE>hashCode</CODE> in the 
class <CODE>Thing</CODE>, allowing you to use the <CODE>contains</CODE> method 
of different lists and collections. Implement the methods without taking into 
consideration the value of the object variable <CODE>weight</CODE>. <EM>Of 
course, you can use NetBeans functionality to implement equals and 
hashCode.</EM></P>
<H4>Maximum Weight Box</H4>
<P>Implement the class <CODE>MaxWeightBox</CODE> in the package 
<CODE>boxes</CODE>; the class inherits <CODE>Box</CODE>. MaxWeightBox has the 
constructor <CODE>public MaxWeightBox(int maxWeight)</CODE>, which determines 
the box maximum weight. Things can be added to MaxWeightBox if and only if the 
thing weight does not exceed the box weight.</P>
<PRE class="sh_java">        MaxWeightBox coffeeBox = new MaxWeightBox(10);
        coffeeBox.add(new Thing("Saludo", 5));
        coffeeBox.add(new Thing("Pirkka", 5));
        coffeeBox.add(new Thing("Kopi Luwak", 5));

        System.out.println(coffeeBox.isInTheBox(new Thing("Saludo")));
        System.out.println(coffeeBox.isInTheBox(new Thing("Pirkka")));
        System.out.println(coffeeBox.isInTheBox(new Thing("Kopi Luwak")));
</PRE>
<PRE>true
true
false
</PRE>
<H4>One-Thing Box and Black-Hole Box</H4>
<P>Next, implement the class <CODE>OneThingBox</CODE> in the package 
<CODE>boxes</CODE>; the class inherits <CODE>Box</CODE>. OneThingBox has the 
constructor <CODE>public OneThingBox()</CODE>, and only one thing can fit there. 
If the box already contains one thing, this should not be changed. The weight of 
the added thing is not important.</P>
<PRE class="sh_java">        OneThingBox box = new OneThingBox();
        box.add(new Thing("Saludo", 5));
        box.add(new Thing("Pirkka", 5));

        System.out.println(box.isInTheBox(new Thing("Saludo")));
        System.out.println(box.isInTheBox(new Thing("Pirkka")));
</PRE>
<PRE>true
false
</PRE>
<P>Next, implement the class <CODE>BlackHoleBox</CODE> in the package 
<CODE>boxes</CODE>; the class inherits <CODE>Box</CODE>. BlackHoleBox has the 
constructor <CODE>public BlackHoleBox()</CODE>; any thing can be added to a 
black-hole box, but none will be found when you'll look for them. In other 
words, adding things must always work, but the method <CODE>isInTheBox</CODE> 
has to return always false.</P>
<PRE class="sh_java">        BlackHoleBox box = new BlackHoleBox();
        box.add(new Thing("Saludo", 5));
        box.add(new Thing("Pirkka", 5));

        System.out.println(box.isInTheBox(new Thing("Saludo")));
        System.out.println(box.isInTheBox(new Thing("Pirkka")));
</PRE>
<PRE>false
false
</PRE></DIV></DIV>
<H3>Removing Objects from an ArrayList</H3>
<P>In the following exercise we see what you may end up to, when you want to 
remove a part of the list objects while parsing an ArrayList:</P>
<PRE class="sh_java">   // somewhere, with a definition like:
   // ArrayList&lt;Object&gt; list = new ...

   for ( Object object : list ) {
      if ( hasToBeRemoved(object) ) {
         list.remove(object);
      }
   }
</PRE>
<P>The solution does not work and it throws a 
<CODE>ConcurrentModificationException</CODE>, because it is not possible to 
modify a list while parsing it with a <EM>foreach</EM> iterator. We will come 
back to the topic better on week 12. If you run into such a situation, you can 
handle it in the following way:</P>
<PRE class="sh_java">   // somewhere, with a definition like:
   // ArrayList&lt;Object&gt; list = new ...

   ArrayList&lt;Object&gt; toBeRemoved = new ArrayList&lt;Object&gt;();

   for ( Object object : list ) {
      if ( hasToBeRemoved(object) ) {
         toBeRemoved.add(object);
      }
   }

   list.removeAll(toBeRemoved);
</PRE>
<P>The objects which have to be deleted are gathered together while we parse the 
list, and the remove operation is executed only after parsing the list.</P>
<DIV class="tehtavat">
<DIV class="tehtava">
<H3>Dungeon</H3>
<P><EM>This exercise is worth four points.</EM> Attention! Implement all the 
functionality in the package <CODE>dungeon</CODE>.</P>
<P><B>Attention: you can create only one Scanner object to make your tests work. 
Do not use Scandinavian letters in the class names. Also, do not use static 
variables, the tests execute your program many different times, and the static 
variable values left from the previous execution would possibly disturb 
them!</B></P>
<P>In this exercise, you implement a dungeon game. In the game, the player is in 
a dungeon full of vampires. The player has to destroy the vampires before his 
lamp runs out of battery and the vampires can suck his blood in the darkness. 
The player can see the vampires with a blinking of their lamp, after which they 
have to move blind before the following blinking. With one move, the player can 
walk as many steps as they want.</P>
<P>The game situation, i.e. the dungeon, the player and the vampires are shown 
in text form. The first line in the print output tells how many moves the player 
has left (that is to say, how much battery the lamp has). After that, the print 
output shows player and vampire positions, which in turn are followed by the 
game map. In the example below, you see the player (<CODE>@</CODE>) and three 
vampires (<CODE>v</CODE>); in this case, the player has enough light for 
fourteen moves.</P>
<PRE>14

@ 1 2
v 6 1
v 7 3
v 12 2

.................
......v..........
.@.........v.....
.......v.........
</PRE>
<P>The example above shows the lamp has enough battery for 14 blinkings. The 
player <CODE>@</CODE> is located at <CODE>1 2</CODE>. Note that the coordinates 
are calculated starting from the high left corner of the game board. In the map 
below, the character <CODE>X</CODE> is located at <CODE>0 0</CODE>, 
<CODE>Y</CODE> is at <CODE>2 0</CODE> and <CODE>Z</CODE> is at <CODE>0 
2</CODE>.</P>
<PRE>X.Y..............
.................
Z................
.................
</PRE>
<P>The user can move by giving a sequence of commands and pressing Enter. The 
commands are:</P>
<UL>
  <LI><CODE>w</CODE> go up</LI>
  <LI><CODE>s</CODE> go down</LI>
  <LI><CODE>a</CODE> go left</LI>
  <LI><CODE>d</CODE> go right</LI></UL>
<P>When the user commands are executed (the user can give many commands at 
once), a new game situation is drawn. If the lamp charge reaches 0, the game 
ends and the text <CODE>YOU LOSE</CODE> is printed on the board. </P>
<P>The vampires move randomly in the game, and they take one step for each step 
the player takes. If the player and a vampire run into each other (even 
momentarily) the vampire is destroyed. If a vampire tries to step outside the 
board, or into a place already occupied by another vampire, the move is not 
executed. When all the vampires are destroyed, the game ends and it prints 
<CODE>YOU WIN</CODE>.</P>
<P>In order to help the tests, create the class <CODE>Dungeon</CODE> in your 
game, with:</P>
<P></P>
<UL>
  <LI>the constructor <STRONG><CODE>public Dungeon(int length, int height, int 
  vampires, int moves, boolean vampiresMove)</CODE></STRONG>       
  <P>the values <CODE>length</CODE> and <CODE>height</CODE> represent the 
  dimension of the dungeon (always a rectangle); <CODE>vampires</CODE> stands 
  for the initial number of vampires (the positions of the vampires can be 
  decided randomly); <CODE>moves</CODE> determines the initial number of moves; 
  and if <CODE>vampiresMove</CODE> is <CODE>false</CODE>, the vampires do not 
  move.</P></LI>
  <LI>the method <STRONG><CODE>public void run()</CODE></STRONG>, which starts 
  the game</LI></UL>
<P><EM>Attention!</EM> The player starts the game in the position 0,0!</P>
<P><EM>Attention!</EM> Player and vampires can not move out of the dungeon and 
two vampires cannot step into the same place!</P>
<P>Below, you find a couple of examples to help you to understand the situation 
better:</P>
<PRE>14

@ 0 0
v 1 2
v 7 8
v 7 5
v 8 0
v 2 9

@.......v.
..........
.v........
..........
..........
.......v..
..........
..........
.......v..
..v.......

<FONT color="red">ssd</FONT>
13

@ 1 2
v 8 8
v 7 4
v 8 3
v 1 8

..........
..........
.@........
........v.
.......v..
..........
..........
..........
.v......v.
..........

<FONT color="red">ssss</FONT>
12

@ 1 6
v 6 9
v 6 5
v 8 3

..........
..........
..........
........v.
..........
......v...
.@........
..........
..........
......v...

<FONT color="red">dd</FONT>
11

@ 3 6
v 5 9
v 6 7
v 8 1

..........
........v.
..........
..........
..........
..........
...@......
......v...
..........
.....v....

<FONT color="red">ddds</FONT>
10

@ 6 7
v 6 6
v 5 0

.....v....
..........
..........
..........
..........
..........
......v...
......@...
..........
..........

<FONT color="red">w</FONT>
9

@ 6 6
v 4 0

....v.....
..........
..........
..........
..........
..........
......@...
..........
..........
..........

<FONT color="red">www</FONT>
8

@ 6 3
v 4 0

....v.....
..........
..........
......@...
..........
..........
..........
..........
..........
..........

<FONT color="red">aa</FONT>
7

@ 4 3
v 4 2

..........
..........
....v.....
....@.....
..........
..........
..........
..........
..........
..........

<FONT color="red">w</FONT>
YOU WIN
</PRE></DIV></DIV></DIV></DIV></DIV><!-- /inner --> 
  </DIV><!-- /node-323 -->         </DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper --> 
    
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --> 
 </DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- /content-content -->             
                                                  </DIV><!-- /content-inner-inner --> 
                            </DIV><!-- /content-inner -->                        
   </DIV><!-- /content-region-inner -->                         </DIV><!-- /content-region --> 
                        
<DIV class="content-bottom row nested " id="content-bottom">
<DIV class="content-bottom-inner inner clearfix" id="content-bottom-inner">
<DIV class="block block-block odd first last grid16-16" id="block-block-1">
<DIV class="inner">
<DIV class="corner-top">
<DIV class="corner-top-right corner"></DIV>
<DIV class="corner-top-left corner"></DIV></DIV>
<DIV class="inner-wrapper">
<DIV class="inner-inner">
<DIV class="content clearfix">
<DIV id="header-top-block">
<P class="rtecenter">Ohjaus: <A href="http://mooc.fi/content/irc-ohjeet">IRCnet 
#mooc.fi </A>&nbsp;&nbsp; |  Tiedotus: <A href="http://twitter.com/mooc1"><IMG 
height="50" style="vertical-align: middle;" src="Inheritance_files/twitter_newbird_blue.png"> 
Twitter </A><A href="http://www.facebook.com/Moocfi"><IMG height="30" style="padding: 10px; vertical-align: middle;" 
src="Inheritance_files/f_logo-1.png"> Facebook</A>  |  Virheraportit: <A href="http://sourceforge.net/p/mooc-issues/tickets/"><IMG 
height="30" style="padding: 10px; vertical-align: middle;" src="Inheritance_files/sf-footer-logo.png"> 
SourceForge</A></P>
<P class="rtecenter"><A href="http://www.cs.helsinki.fi/"><IMG width="400" 
style="vertical-align: middle;" alt="Helsingin yliopiston tietojenkäsittelytieteen laitos" 
src="Inheritance_files/CS-logo-MOOC.jpg">&nbsp; </A></P></DIV>
<SCRIPT>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 
  ga('create', 'UA-47575342-3', 'auto');
  ga('send', 'pageview');
 
</SCRIPT>
        </DIV></DIV><!-- /inner-inner -->	   </DIV><!-- /inner-wrapper -->     
<DIV class="corner-bottom">
<DIV class="corner-bottom-right corner"></DIV>
<DIV class="corner-bottom-left corner"></DIV></DIV></DIV><!-- /inner --> </DIV><!-- /block --></DIV><!-- /content-bottom-inner --> 
</DIV><!-- /content-bottom -->                       </DIV><!-- /content-group-inner --> 
                    </DIV><!-- /content-group -->                                
       </DIV><!-- /main-content-inner -->                 </DIV><!-- /main-content --> 
                              </DIV><!-- /main-group-inner -->             
</DIV><!-- /main-group -->           </DIV><!-- /main-inner -->         </DIV><!-- /main --> 
      </DIV><!-- /main-wrapper -->       <!-- postscript-bottom row: width = grid_width --> 
            <!-- footer row: width = grid_width -->             <!-- footer-message row: width = grid_width --> 
      
<DIV class="footer-message-wrapper full-width" id="footer-message-wrapper">
<DIV class="footer-message row grid16-16" id="footer-message">
<DIV class="footer-message-inner inner clearfix" id="footer-message-inner">
<DIV class="footer-message-text block" id="footer-message-text">
<DIV class="footer-message-text-inner inner clearfix" id="footer-message-text-inner"><BR></DIV><!-- /footer-message-text-inner --> 
</DIV><!-- /footer-message-text -->                    </DIV><!-- /footer-message-inner --> 
        </DIV><!-- /footer-message -->       </DIV><!-- /footer-message-wrapper --> 
    <!-- /page-inner -->   <!-- /page -->   </BODY></HTML>
